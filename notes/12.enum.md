# 简单说明

在 `Rust` 中，`enum（枚举）`是一种非常强大和灵活的数据类型，它不仅仅是像 C/C++ 那样的「一组常量的集合」，
更像是一个可以携带数据的`代数数据类型（Algebraic Data Type, ADT）`。

`枚举`常用于表示`多种可能的状态、类型或事件`，是 `Rust` 安全性和表达力的重要来源之一。


# 具体的枚举 `enum` 的使用

以下主要列举了 rust 中的 枚举 `enum` 常用场景。

## 1. 一组互斥的常量

这是枚举中最简单的使用场景,类似于其他语言的`枚举`，表示`一组互斥的常量`，详情如下：

```rust


enum Direction {
    _Up,  // 为了防止未使用的 枚举 变量的 编译警告，可以使用 下划线定义
    _Down,
    _Left,
    _Right,
}

fn main() {
    //  使用 ：：获取枚举中的指定的值
    // Direction::Up 表示 Direction 枚举的一个成员。
    let dir = Direction::_Up;

    // 根据不同的 枚举的值 执行指定的，打印的操作
    // match 表达式用来对枚举的不同变体进行穷尽匹配（必须覆盖所有可能的变体）
    match dir {
        Direction::_Up => println!("Going up"),
        Direction::_Down => println!("Going down"),
        Direction::_Left => println!("Going left"),
        Direction::_Right => println!("Going right"),
        // 可以不写下面的 default 逻辑， 防止 编译中的 warning，因为上面已经穷尽了，如果上面没有写完所有的 enum 中的元素，可以添加下面的使用这个 default 逻辑，防止报错
        // _ => println!("no cuttent direction !")  
    }
}

```

## 2. 携带数据

`Rust` 的`enum 枚举`可以为每个变体携带不同类型和数量的数据，这是其强大之处。例如：

```rust

enum Message {
    Quit,                       // 不携带数据
    Move { x: i32, y: i32 },    // 匿名结构体
    Write(String),              // 元组变体
    ChangeColor(i32, i32, i32), // 多个值
}

fn main() {
    // 使用 array 定义一个 Message 的列表，其中列表中每个元素都是我们定义的 enum 的 Message 的某个成员
    //  [Message; 4] 指定当前 msgs 是一个 array , 其中每个成员都是一个 Message 对象，同时长度 为 4
    let msgs: [Message; 4] = [  // 为每个 array 的 子元素 携带对应的参数
        Message::Quit,
        Message::Move { x: 10, y: 20 },
        Message::Write("Hello".to_string()),  
        Message::ChangeColor(255, 0, 0),
    ];

    // 循环获取拥有迭代器的 msgs 的 array 列表
    for msg in msgs {
        //  根据 msg 去匹配指定的成员
        match msg {
            Message::Quit => println!("Quit message"),
            //  注意，下面必须像下面这么写，进行结构，不能这么写， Message::Move => println!("Move action"),
            //  这是因为 Message::Move 这个枚举变体携带了数据，而你的匹配分支没有对这些数据进行「解构」或者「忽略」，导致匹配模式不完整，从而报错。
            //  但是如果你不关心数据，也可以这么写 Message::Move { .. } => println!("Move action"),
            //  因为 .. 已经代表了析构，代表「忽略这个结构体里的其他字段」，相当于 _ 的结构体版，故而数据结构正确匹配，不报错 
            Message::Move { x, y } => println!("Move to x={x}, y={y}"),
            Message::Write(text) => println!("Text: {text}"),
            Message::ChangeColor(r, g, b) => println!("Color: ({r},{g},{b})"),
        }
    }

    /*
    以上的代码输出如下：
        Quit message
        Move to x=10, y=20
        Text: Hello
        Color: (255,0,0)
    */ 
}

```


>  补充一点， `Rust` 会为每个变体自动分配一个`「判别值」`，你也可以手动指定，但是，手动分配判别值仅适用于`无数据的枚举`.
详情如下：

Rust 的枚举在底层类似 C 的 tagged union（带标签的联合体）：
- 枚举的内存大小取决于：
  - 变体中最大的数据大小
  - 标签（discriminant）判别式的大小，通常是一个整数（Rust 自动决定）

> `整个 enum 的大小` = `所有变体中最大的数据大小` + `额外的 discriminant（标签）大小` + `padding`。


```rust
enum MyEnum {
    A,          // 0 bytes
    B(i32),     // 4 bytes
    C(i64),     // 8 bytes
}


// 自定义一个 枚举，并且其中成员中，每个变体（成员）被显式赋值。
// Rust 默认底层类型是 isize，可以通过 as 转换成整数。
enum Number {
    One = 1, // 注意这里的显示指定的值必须是 isize 类型
    Two = 2,
    Three = 3,
}


fn main() {
    // 获取 自定义 MyEnum 的内存占用的大小
    // 这个是 Rust 内置自定的 std::mem::size_of 方法
    println!("Size of MyEnum: {}", std::mem::size_of::<MyEnum>()); // 通常是 16 bytes (8 for largest + tag padding)
    // 由于 Rust 没有直接获取枚举成员的类型的方法，所以下面只能自己手动指定具体的类型
    println!("Size of variant B's data (i32): {}", size_of::<i32>());  // 打印： Size of variant B's data (i32): 4
    println!("Size of variant C's data (i64): {}", size_of::<i64>());  // 打印： Size of variant C's data (i64): 8


    // Rust 默认底层类型是 isize，可以通过 as 转换成整数。
    let to_test: Number = Number::One;
    match to_test { 
        Number::One => println!("the value of the to_test is {}",to_test as u8),
        Number::Two => println!("the value of the to_test is {}",to_test as u8),
        // 除了以上，还可以像下面这么写
        Number::Three => println!("the value of the to_test is {}",Number::Three as u8),
    }

    // 以上运行结果为 ： the value of the to_test is 1
}


```


## 3. 枚举可以实现方法（impl）

除了 `struct 结构体` 和 `trait 特征`， 对于 `enum` 而言，它也可以借助 `impl` 实现方法， 详情如下：

```rust

// 定义一个 枚举， 其成员都是 携带数据的 元组结构体
enum Shape {
    Circle(f64),  // 携带数据的 元组结构体 tuple struct
    Rectangle(f64,f64) // 携带数据的 元组结构体 元组结构体 tuple struct
}

// 实现枚举, 添加自定义方法
impl Shape {
    // 在当前枚举中定义一个方法 area
    // self 代表枚举实例，可以用 match 解构内部不同变体。
    fn area(&self) -> f64 {
        //  根据当前的实例本身的不同，计算当前 shape 的面积
        // std::f64::consts::PI 是 圆周率常量
        match self {
            Shape::Circle(r) => std::f64::consts::PI * r * r, //  圆的面积
            Shape::Rectangle(w, h) => w * h,   // 长方形的面积
        }
    }
}

fn main() {
    // 创建两个 Shape 对象
    let c = Shape::Circle(2.0);
    let r = Shape::Rectangle(3.0, 4.0);

    println!("Circle area = {}", c.area());  // 打印： Circle area = 12.566370614359172
    println!("Rectangle area = {}", r.area()); // 打印： Rectangle area = 12
}


```


## 4. 常见枚举：`Option` 和 `Result`

Rust 标准库广泛使用枚举来代替 null 和异常机制。
而对于 `Option` 可以类比于 `TypeScript` 类型检查里面的 `partial`，而 `Result` 就好比是处理 请求的 返回的结果值。

> `Option<T>`：表示一个值要么存在，要么不存在

```rust


// 下面枚举，其中 T 代表泛型
enum Option<T> { // 用 Option 替代 null，强制编译期处理「值可能为空」的情况。
    None,   // 如果传入的类型不是 我们指定的 T 或者为空值 时候，会返回 None 对象
    Some(T),// 如果传入的类型 是 我们指定的 T 并且不为空值 时候，会返回 Some(T) 的结果
}

fn main() {

    // 注意枚举的变体的实现，只能一个一个单独的实现
    // let a: Option<i32> = Option::None;      // 枚举是 None 变体
    let b: Option<i32> = Option::Some(10);     // 枚举是 Test 变体， 具体的值的指定，只能手动一个个的执行，如果想同统一的实例化成一个对象，需要使用 Struct 而不是 enum 的数据结构
    match b {
        Option::Some(n) => println!("Got {}", n),
        Option::None => println!("Nothing"),
    }
    
    // 以上打印： Got 10
}

```

除了以上手动定义,其中系统自带就有 Option 这个枚举，故此，以上代码可以直接像下面这么写

```rust
// 下面枚举，其中 T 代表泛型
// enum Option<T> { // 用 Option 替代 null，强制编译期处理「值可能为空」的情况。
//     None,
//     Test(T),
// }

fn main() {

    // 注意枚举的变体的实现，只能一个一个单独的实现
    // let a: Option<i32> = None;      // 枚举是 None 变体
    let b: Option<i32> = Some(10);    // 直接调用系统自带的 Option 枚举去实现里面成员变体
    match b {
        Some(n) => println!("Got {}", n),
        None => println!("Nothing"),
    }
    
    // 以上打印： Got 10
}


```

而借助 `Option` 我们可以直接定义这样的 `结构体 struct`

```rust

// 这样一看你就明白了
struct MyTest {
    a: Option<i32>,
    b: Option<i32>
}

```

以上可以简单类比如 `TypeScript` 中的`type 类型`, 其中代码如下：

```ts
type MyTest = {
  a?: number;
  b?: number;
};

```


> `Result<T, E>`：表示一个操作可能成功（Ok）或失败（Err）

```rust

// 注意下面除了像下面这种自定义，对于这个 Result 是 Rust 中内置的
#[derive(Debug)] // 开启 debug
enum Result<T, E> {
    Ok(T),
    Err(E),
}

fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Result::Err("Division by zero".to_string())
    } else {
        Result::Ok(a / b)
    }
}

fn main() {
    let result_1 =  divide(10.0, 0.0);
    println!("the result is:  {result_1:?}"); // 打印： the result is:  Err("Division by zero")
    match result_1 {
        Result::Ok(v) => println!("Result: {}", v),
        Result::Err(e) => println!("Error: {}", e),
    }

    // 以上打印： Error: Division by zero

    let result_2 =  divide(10.0, 1.0);
    println!("the result is:  {result_2:?}"); // 打印： the result is:  Ok(10.0) 
    match result_2 {
        Result::Ok(v) => println!("Result: {}", v),
        Result::Err(e) => println!("Error: {}", e),
    }

    // 以上打印： Error: Result: 10
}

```
除了上面手动定义的 Result 类型，也可以直接将以上代码全部像下面这种重写，
表示手动调用 Rust 内置的 枚举对象 `Result`, 它里面也有两个成员 `成功（Ok）`和`失败（Err）`


```rust

//  下面的 Err 和 Ok 是Rust 原生内置的 Result 这个枚举的两个成员，Err 和 Ok， 分别代表失败和成功
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
       Err("Division by zero".to_string())
    } else {
       Ok(a / b)
    }
}

fn main() {
    let result_1 =  divide(10.0, 0.0);
    println!("the result is:  {result_1:?}"); // 打印： the result is:  Err("Division by zero")
    match result_1 {
        Ok(v) => println!("Result: {}", v),
        Err(e) => println!("Error: {}", e),
    }

    // 以上打印： Error: Division by zero

    let result_2 =  divide(10.0, 1.0);
    println!("the result is:  {result_2:?}"); // 打印： the result is:  Ok(10.0) 
    match result_2 {
        Ok(v) => println!("Result: {}", v),
        Err(e) => println!("Error: {}", e),
    }

    // 以上打印： Error: Result: 10
}
```

## 5. 枚举与 if let / while let 简写

详细如下例所示，但是一般为了让代码清晰和美观，如无必要，最好不要像下面这么做

```rust

fn main() {
    // 当你只关心一种变体时，可以用 if let 简化 match：
    let some_val = Some(5);
    
    // 直接写表达式和赋值，这与 js 非常相似
    if let Some(v) = some_val {
        println!("Value is {}", v); // 打印： Value is 5
    }
    // 或使用 while let 进行循环模式匹配：
    let mut stack = vec![1, 2, 3];

    // 直接写表达式和赋值，这与 js 非常相似
    while let Some(top) = stack.pop() {
        println!("Popped {}", top);
    }

    /*
     以上结果打印：
      Popped 3
      Popped 2
      Popped 1
    */ 
}

```


# 一些总结和补充

## 枚举与 struct 的对比

| 特性     | `struct`          | `enum`                              |
| --------| -----------------  | ----------------------------------- |
| 表示形式 | 固定的一种数据结构 | 多种互斥的数据结构                    |
| 适用场景 | 一种确定的类型     | 多种可能的类型或状态，且同时只存在一种  |
| 携带数据 | 所有字段固定       | 不同变体携带不同数量和类型的数据       |
| 模式匹配 | 可解构             | 强制穷尽匹配，防止遗漏任何一种可能      |


## 对以上`枚举`的简单总结

| 特性             | 枚举（`enum`）                                |
| ---------------- | ------------------------------------------------------------------- |
| 用途             | 表示一组互斥的可能性，尤其适用于状态机、数据类型联合、错误处理等          |
| 携带数据         | ✅ 每个变体可以有不同的字段结构                                        |
| 内存安全         | ✅ 类型系统 + `match` 穷尽匹配避免遗漏                                 |
| 常见应用         | `Option<T>`、`Result<T, E>`、状态管理、AST、消息传递等                 |
| 与结构体的区别    | `枚举是多种数据结构的「联合」`，`而结构体是单一固定结构` (这一点尤为重要) |
