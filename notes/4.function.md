# 在rust中的简单函数











# 一些另外的拓展比较

## 宏（macro） 和 函数（function）的区别

在 Rust 中，`宏（macro）` 和 `函数（function）` 虽然在使用时非常类似，都只是一种直接的调用，都可以用来执行代码，
但它们有 显著的区别，因此不能简单地将宏理解为函数。
虽然宏和函数看起来有相似之处（都可以用来处理参数并执行操作），但它们的实现机制、用途和工作方式完全不同。


### 1. 宏与函数的主要区别
- 编译时执行 vs 运行时执行
    - `函数` 是 `运行时` 执行的。它的参数在程序运行时传递，执行结果依赖于实际的参数值。
    - `宏` 是 `编译时` 执行的。宏在编译时展开，生成的代码会被插入到源代码中，然后再编译。这意味着宏在运行时不会直接执行，而是生成新的代码。

- 代码展开 vs 函数调用
    - `函数` 通过`调用`来执行，调用时会创建一个新的栈帧来处理函数的参数和局部变量。
    - `宏` 通过 `代码展开` 来工作，`宏的执行本质上是将宏定义的规则应用于调用它的位置，将其转化为生成的代码片段，直接插入源代码中`。

- 参数处理方式
    - `函数` 的参数是 `固定的类型` 和 `数量`，并且函数参数在编译时被解析为实际的值。
    - `宏` 允许使用 `不定数量的参数`，并且它可以在编译时根据提供的参数类型和数量做出不同的处理。这使得宏更为灵活，能够动态生成代码。

- 调试和错误检查
    - `函数` 在`编译时`进行类型检查和错误检查，这些错误可以在`编译`阶段被捕获。
    - `宏` 的错误通常在 `宏展开后` 才能看到，因此宏的调试相对更加困难，错误信息也往往更加复杂。

### 2. 宏的工作方式
宏并不是简单的代码块，它的执行实际上是在 `编译阶段` 将宏的定义“展开”为新的代码。

比如，在使用 `vec!` 宏时，宏会在编译时将 `vec!` 的输入（如 `[1, 2, 3]`）转化为一个具体的 `Vec` 构造函数调用。

```rs
let v = vec![1, 2, 3];
// 编译器会在编译时将上面这个宏创建的动态数组转化为：
let v = Vec::from([1, 2, 3]);
```

### 3. 宏的应用

`宏`在 Rust 中主要用于一些需要 `生成重复代码`(这一点与函数有点类似) 或 `条件化代码` 的场景。常见的宏应用有：
- `生成重复代码`： vec! 宏、println! 宏等
- `条件化编译`： 例如在不同的平台使用不同的代码，cfg! 宏
- `简化代码`： 如 lazy_static! 宏用于初始化常量

### 4. 举例：宏与函数对比

```rs
//  函数: 这个函数在运行时被调用，接收两个参数，并返回它们的和。
fn add(x: i32, y: i32) -> i32 {
    x + y
}

// 宏: 这里的 add! 宏并不会直接在运行时执行，而是将 1 + 2 这部分代码插入到调用位置，编译时展开为 1 + 2。
macro_rules! add {
    ($x:expr, $y:expr) => {
        $x + $y
    };
}
// 调用宏，在编译时 生成的代码相当于：1 + 2
let result = add!(1, 2);

```

### 5. 总结：
`宏`和`函数`的主要区别在于 `执行时机`，`函数在运行时执行`，`而宏在编译时执行`。
> `宏`生成的是 `代码片段`，它在编译时被展开并插入源代码中，而函数通过 调用栈 执行，并且可以在运行时传递参数。
> `宏`提供了更多的 `灵活性` 和 `元编程`能力，但也带来了更复杂的调试和理解难度。
所以，虽然宏和函数在表面上可能有一些相似之处，但本质上它们的工作方式、用途和运行时表现是完全不同的。
