# 在rust中的函数

首先，必须知道一点是，对于 `rust` 而言，它的编译执行，一定需要有一个 `main` 函数作为所有的执行和启动的入口，这一点和 `c#` 也是类似的，一点不能缺少这个函数



# 在 `rust` 中特有的代码块

下面可以理解为是 rust 特有的一个数据结构类型，即`代码块`,它与函数不同，只是一个普通的小型代码片段，
同时下面的变量使用 `_` 开头只是告诉 `rust` 编译器，下面的只是一个定义而未使用的变量，可以防止编译报错。

另外代码块不能结尾包含 `";"`,如果包含分号，则会返回一个空的 `()（单元类型）` 

```rust
// 下面可以理解为是 rust 特有的一个数据结构类型，即代码块
// 同时下面的代码块返回的是代码块默认最后一行的值，如果将最后一行去掉，则返回默认的空的 单元类型 (),注意，她只是一个空类型不是 tuple数据类型
fn main() {
    // human_inform("Bertram",18,175.0)

    let _x_1 = {
        let _qty = 10;
        let _price = 5;
        _qty * _price; // 不能有分号，它会被认为是一个 ()（单元类型）， 注意它不是 tuple 类型,此时返回 空的 ()（单元类型）
    };
    println!("total price is {_x_1:?}",); // 因为最后一行有分号，此时打印: total price is (), 其中是 ()（单元类型）

    let _x_2 = {
        let _qty = 10;
        let _price = 5;
        _qty * _price // 没有分号，会被认为代码块的正常返回，返回为 50 ，类型为 i32
    };
    println!("total price is {_x_2:?}",); // 此时打印: total price is 50， 因为最后一行没有分号，同时，即使简单类型也可以使用 {:?} 的debug模式来打印,并不会报错

    let _x_3 = {
        let _qty = 10;
        let _price = 5;
        (_qty,_price)  // 这个才是一个真正的 tuple 数据类型，即此时返回的是 (10, 5)
    };
    println!("total price is {_x_3:?}",); // 此时打印: total price is (10,5)， 因为最后一行没有分号,并且是 tuple 类型
}

```

# 实际函数的一些编写

## 1. `rust` 中函数编写的规则

- `rust` 函数定义使用 `fn` 关键字
- `rust` 函数的函数名必须使用 `snake case` 命名法， 也就是使用小写和下划线表示函数
- `rust` 函数的执行或者 `rust` 本身程序的启动，必须至少定义一个 `main` 函数作为入口函数
- `rust` 函数在同一个文件中去定义时，可以在 `main` 函数后面去定义，并且在 `main` 函数中能正常调用，这一点被称为 `hoisting`, 
         也就是说函数的定义顺序，不影响其执行和调用， 这一点可以类比 `js` 文件中定义函数，然后在同一个文本中，可以随意调用。
- `rust` 中如果函数有返回值，其函数定义的结尾，必须需要使用 `->` 表明当前函数返回的数据类型

```rust

fn main() {
    let height = human_inform("Bertram",18,175.577);
    print!("final get height is {height}")

    // 以上的运行结果如下：
    // hello , my name is Bertram, I am 18 years old, and my height is 175.58 cm.
    // final get height is 175.577
}

fn  human_inform(name:&str,age:i32,height:f32) -> f32 {
    // 其中 {height:.2} 表示保留两位小数,同时它会自动进行四舍五入；
    println!("hello , my name is {name}, I am {age} years old, and my height is {height:.2} cm.");
    // 可以使用 return 关键字直接 return 结果 
    // return height;  // 本质可以理解为一个简单的 statement，结尾必须携带 分号
    // 也可以不使用 return关键字，直接这么写，也可以返回结果，但是需要注意的是，下面这种写法，不能使用 分号结尾
    height  // 本质可以理解为一个简单的 expression 因为其自身作为 return 的返回结果，所以结尾不能携带分号

    // 这是因为对于以上的结果，需要理解两个概念
    // 1. expression： 所有有返回值的代码，可以称为表达式
    // 2. statement: 所有没有返回值的代码，可以称为语句
    // 在 rust 中所有的几乎所有的 statement 的结尾必须携带 分号
}


```


# 一些另外的拓展比较

## 宏（macro） 和 函数（function）的区别

在 Rust 中，`宏（macro）` 和 `函数（function）` 虽然在使用时非常类似，都只是一种直接的调用，都可以用来执行代码，
但它们有 显著的区别，因此不能简单地将宏理解为函数。
虽然宏和函数看起来有相似之处（都可以用来处理参数并执行操作），但它们的实现机制、用途和工作方式完全不同。


### 1. 宏与函数的主要区别
- 编译时执行 vs 运行时执行
    - `函数` 是 `运行时` 执行的。它的参数在程序运行时传递，执行结果依赖于实际的参数值。
    - `宏` 是 `编译时` 执行的。宏在编译时展开，生成的代码会被插入到源代码中，然后再编译。这意味着宏在运行时不会直接执行，而是生成新的代码。

- 代码展开 vs 函数调用
    - `函数` 通过`调用`来执行，调用时会创建一个新的栈帧来处理函数的参数和局部变量。
    - `宏` 通过 `代码展开` 来工作，`宏的执行本质上是将宏定义的规则应用于调用它的位置，将其转化为生成的代码片段，直接插入源代码中`。

- 参数处理方式
    - `函数` 的参数是 `固定的类型` 和 `数量`，并且函数参数在编译时被解析为实际的值。
    - `宏` 允许使用 `不定数量的参数`，并且它可以在编译时根据提供的参数类型和数量做出不同的处理。这使得宏更为灵活，能够动态生成代码。

- 调试和错误检查
    - `函数` 在`编译时`进行类型检查和错误检查，这些错误可以在`编译`阶段被捕获。
    - `宏` 的错误通常在 `宏展开后` 才能看到，因此宏的调试相对更加困难，错误信息也往往更加复杂。

### 2. 宏的工作方式
宏并不是简单的代码块，它的执行实际上是在 `编译阶段` 将宏的定义“展开”为新的代码。

比如，在使用 `vec!` 宏时，宏会在编译时将 `vec!` 的输入（如 `[1, 2, 3]`）转化为一个具体的 `Vec` 构造函数调用。

```rs
let v = vec![1, 2, 3];
// 编译器会在编译时将上面这个宏创建的动态数组转化为：
let v = Vec::from([1, 2, 3]);
```

### 3. 宏的应用

`宏`在 Rust 中主要用于一些需要 `生成重复代码`(这一点与函数有点类似) 或 `条件化代码` 的场景。常见的宏应用有：
- `生成重复代码`： vec! 宏、println! 宏等
- `条件化编译`： 例如在不同的平台使用不同的代码，cfg! 宏
- `简化代码`： 如 lazy_static! 宏用于初始化常量

### 4. 举例：宏与函数对比

```rs
//  函数: 这个函数在运行时被调用，接收两个参数，并返回它们的和。
fn add(x: i32, y: i32) -> i32 {
    x + y
}

// 宏: 这里的 add! 宏并不会直接在运行时执行，而是将 1 + 2 这部分代码插入到调用位置，编译时展开为 1 + 2。
macro_rules! add {
    ($x:expr, $y:expr) => {
        $x + $y
    };
}
// 调用宏，在编译时 生成的代码相当于：1 + 2
let result = add!(1, 2);

```

### 5. 总结：
`宏`和`函数`的主要区别在于 `执行时机`，`函数在运行时执行`，`而宏在编译时执行`。
> `宏`生成的是 `代码片段`，它在编译时被展开并插入源代码中，而函数通过 调用栈 执行，并且可以在运行时传递参数。
> `宏`提供了更多的 `灵活性` 和 `元编程`能力，但也带来了更复杂的调试和理解难度。
所以，虽然宏和函数在表面上可能有一些相似之处，但本质上它们的工作方式、用途和运行时表现是完全不同的。
