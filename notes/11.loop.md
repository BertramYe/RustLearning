# 简单描述

在 `rust` 中除了常用的三种循环外，还可以对于多层循环体而言，为了方便跳转，还可以给其打上指定标题，并借助 `break` 或者 `continue` 关键字进行中断和跳转

# A、Rust 中的 `3` 种循环体

在 Rust 中，其循环结构主要有以下 `3` 种常见和使用的定义方式和使用

## 1. `loop` 循环（无限循环）

它主要利用 `loop` 关键字定义，类似其他语言的 `while(true)` 语法，同时它可以使用 `break` 关键字 携带返回值 `→` 很适合写循环内计算后`退出`时返回结果。

```rust


fn main() {
    let mut  counter:i16 = 0;
    loop {
        if counter <=5 {
            println!("loop {counter} !");
            counter += 1;
        }else {
            println!("exit!");
            break; // 跳出循环不执行后面的步骤
        }
    }

    // 重置
    counter = 0;

    // loop 可以将 break 后面给的值返回
    let loop_result = loop {
        if counter <= 3 {
            counter += 1;
            println!("new result counetr {counter}")
        }else {
            break counter;   // 在这里跳出，此时的 break 可以类比成 return 关键字

            /*
             在这里跳出，此时的 下面这行和上面那行等价，但是这里不能直接这么写，
             因为此的 return 会直接作用于当的 main 函数,即会立即跳出当前的 main函数， 后面都不会执行，同时会报错， 类比使用 match 函数。
             但是为了能 return，可以将当前的 loop 可以重新写入到另外一个新的函数里面，并在 main 函数里面调用就可以
            */ 
            // break return counter;  
        }
    };

    println!("the loop end result : {loop_result}");


    let result = test_loop();
    println!("test loop result : {result}"); // 这一行会打印： test loop result : 5，这是因为内部函数的 return 会将数据正确直接 return 出来

    //  除了loop 还可以使用 continue 关键字
    counter = 0;
    loop {
        counter += 1;
        if counter % 2 == 0 {
            continue; // 偶数直接跳过,重新进行下一轮的循环
        }
        // 偶数不会执行下面这轮打印，这是因为，上面的 continue 会直接回到新一轮的循环，而不执行下面的打印逻辑
        println!("odd number: {i}"); 
        if counter > 10 {
            break;
        }
    }

}


//  测试 return 关键字在 loop 里面的作用
fn test_loop () -> i16 {
    let mut  test_counter: i16 = 0;
    let test_result:i16 = loop {
        if test_counter <= 4 {
            test_counter += 1;
            println!("test loop {test_counter}")
        }else {
            // break return test_counter; // 这一步会直接跳出当前函数,因为有 return
            return test_counter; // 这一步和上面等价，因为 return 会直接作用于当前函数，直接跳转出当前 test_loop 函数，并将 test_counter 返回
        }
    };

    // 下面这行不会被执行，因为上面有 return，会直接跳出当前 test_loop 函数
    println!("test the pirnt of {test_counter}");
    test_result;
}


```


## 2. `while` 循环（条件循环）

`while` 循环在每次迭代前检查条件，当条件为 `true`时执行，否则退出循环,这个和其他语言基本类似，简单来说，就是带条件的无线循环。

```rust

fn main() {
    let mut  counter:i16 = 0;
    while counter < 5 {
        println!("loop for counter {counter}");
        counter += 1;
    }


    // 重置一下
    counter = 0;
    while counter < 10 {
        println!("loop for counter {counter}");
        counter += 1;
        if counter == 4 {
            break;  // 会跳出当前的 while 循环
            // return;  // 注意这里不能使用 return, 道理还是和之前一样，使用return 会直接跳出当前循环的同时，也会直接跳出当前函数，这会导致，后面的逻辑无法被执行
        };
    };
    println!("finally line !");
    /*
       需要说明一下 while 不能像 loop 一样去返回结果然后给到外部一个变量，
       所以像下面这样的代码，对于 while 而言，会直接错的
    */ 
    // counter = 0;
    // let while_result = while counter < 10 {
    //     println!("loop for counter {counter}");
    //     counter += 1;
    //     if counter == 4 {
    //         break counter;
    //     };
    // };


    // 除了 loop 还可以使用 continue 关键字

    counter = 0;
    while counter < 10 {
        counter += 1;
        if counter % 2 == 0 {
            continue;  // 跳过偶数，不执行后面的逻辑，而重新进行下一轮循环
        }
        // 偶数不执行这一行逻辑
        println!("odd number: {counter}");  
    }

}

```


> 另外对于 `Rust` 本身的 `loop` 无限循环和 `while true` 无限循环的简单对比：
> - loop
>    - Rust 把 loop { ... } 视为真正的无限循环。
>    - LLVM 可以做尾递归优化或直接生成无条件跳转的汇编，几乎没有条件判断开销。
>    - 适合写高性能的循环、底层逻辑或需要频繁跳出的场景。
> - while true
>    - 本质是 while 条件 { ... } → 条件为 true。
>    - 编译器可能把它优化掉，但是逻辑上先要检查条件，再执行循环体，存在微小的条件判断开销。
>    - 在极端性能敏感的场景（如内核、游戏循环）可能略慢，但通常可以忽略不计。

>  综合以上，对于无限循环的使用上，还是优先推荐使用 `Rust` 内置的 `loop` 更好，而如果是携带条件的无限循环，推荐使用 `while ...` 



## 3. `for` 循环（迭代器循环）

`for` 循环用于遍历实现了 `IntoIterator` 的对象, 即`具有迭代器性质的对象`，例如 `数组 array`、切片、range 范围等。

同时，它也如 `while` 循环类似，不具备直接 `break` 直接像 `loop` 作为一个表达式 借助 `break` 向外赋值的能力，但是 `break` 的确可以中断当前的循环，

另外，由于`它循环的基础是有限的迭代器对象`，所以它相比较 `loop` 和 `while` 的无线循环而言，它的`安全性更高`一些。 


```rust

fn main() {
    // 遍历数组
    let arr: [i16; 3] = [10, 20, 30];
    for val in arr {
        println!("val = {val}");
        if val == 20 {
            break;  // 跳出当前循环
            // return; 此时使用 return 也是一样的，不仅作用于当前的 for 循环，还会直接从当前的 main 函数中直接返回
        }
    }


    /*
        不可以像 loop 一样直接像下面这样利用 return 赋值，这在 Rust 中是不支持，且还会报错的,这和 while 是一样的
        let a = for val in arr {
            println!("val = {val}");
            if val == 20 {
                break val;  // 此时这么写是不支持的，会报错
            }
        };
        println!("the loop a : {a}");
    */ 

    // 使用 range 范围, 不包含
    for i in 0..5 {   // 0,1,2,3,4（不包括5）
        println!("i = {i}");
    }

    // 使用 range 范围,包含末尾的范围
    for j in 0..=5 { // 0,1,2,3,4,5 (包括5）
        println!("j = {j}");
    }


    for m in 0..10 {
        if m == 5 {
            continue; // 跳过 5，不执行后面的打印逻辑，而是重新进入新的一轮的循环
        }
        //  当 m 为 5 时，不执行下面这一行的打印，因为 continue 会直接重新进入新的一轮的循环
        println!("m = {m}");
    }

}


```



# B. `循环标签（loop labels）`

Rust 支持给循环加`标签`，在嵌套循环中借助 `break/continue` 关键字方便控制退出哪一层循环：

```rust

fn main() {
    // 下面直接给外层for 循环给一个 label 标签，其中标签的名称为 for_outer， 并且使用 单引号 ' 进行标注
    'for_outer: for i in 1..5 {
        for j in 1..5 {
            if i * j == 6 {
                println!("i = {i}, j = {j}");
                break 'for_outer;  // 对于多层循环而言，可以直接跳出外层循环 'for_outer

                // 对于多层循环，也可以像下面一样直接使用 return 返回，只不过他还是像之前一样，会以 当前的 main 函数为基础，直接跳出所有循环之外，
                // 直接跳出当前的 main 函数，而不会执行后面的所有逻辑，故而并不推荐这么做
                // return;    
            }
        }
    }
    println!("jump outer 1");

    //  除了以上的 break 跳到指定标签，也可以使用 continue 关键字跳到指定标签
    'outer: for i in 1..=3 {
        for j in 1..=3 {
            if i == j {
                continue 'outer;  // 直接跳到外层循环的下一个 i
            }
            println!("i = {i}, j = {j}");
        }
    }

    println!("jump outer 2");

    //  下面的 while 和 loop 也有对应的 continue 的跳转功能，对于其重复代码，下面暂时省略了

    let mut counter = 0 ;
    'while_outer: while counter < 10 {
        if counter < 3 {
            counter += 1;
            println!("the counetr is {counter}");
        }else {
            break 'while_outer;
        }
    }
    println!("jump outer 3");

    counter = 0;

    'loop_outer: loop {
        if counter < 6 {
            counter += 1;
            println!("loop counter {counter}")
        }else {
            break 'loop_outer;
        }
    }

    println!("jump outer 4");
}

```








