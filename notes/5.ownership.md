# 关于在 `rust` 中的所有权机制 （ ownership ）

简单来说，对于 `rust` 中的所有权机制,除了出于安全考虑的机制外，主要是为了解决像 C、C++ 中的内存管理的问题，
同时由于 Rust 中没有 `GC (garbage collector)` ， 即 垃圾回收器 ，也就没有向其他动态语言一样的垃圾自动回收机制，
这也体现了 Rust 本身的内存安全的特点，从而对于 rust 本身而言，设计了 `所有权机制 (Ownership)` 

对于 其 `Ownership Rules` 主要有一下三条 （来自 Rust 官网）

- Each value in Rust has an owner
- There can only be one owner at a time
- when the onwer goes out of scope, the value will be dropped

简而言之就是，在 `Rust` 中的 任何变量都应该有且只有一个 所有者，
并且当变量超出所有者的权限范围时，此时在Rust中所对应的变量应该被销毁，
也就是说`在 Rust 中所有的变量应该永远在其唯一的所有者控制之下`。


# 经典的例子

关于以上的 所有权 （ownership） 机制，以下是三个经典的例子


## 1. 变量的所有权的唯一性和所有权的转移

需要注意的是，对于 `所有权转移（Ownership Transfer）`， 以一个变量为例而言， 当一个变量的所有权被转移时，
实际上发生的变化是：

`栈上的指针`：变量本身（在栈上的内存位置，通常是一个指向堆内存的指针）会被移动到新变量或函数中。
`堆上的数据`：堆上的数据本身并不直接移动，但栈上的指针会被移动。因此，新的变量拥有对堆内存的控制权。

```rust 

fn main() {
   
   let _s: String =  String::from("aaaaa");
   let _k: String =  String::from("aaaaa");
   // 第一次能正常打印
   println!("string is {_s}");
   // 此时下面的 “=” 赋值行为，不仅是赋值，同时 _k 中的 "aaaaa" 的所有权从 _k 转移到了 _kk， 故而从此刻开始 _k 会被销毁
   let _kk: String = _k;
   //  此时将 _s 的 所有权进行了转移，也就是将 _s 所有权转移给了 caculte_len 函数中的入参 s
   let _len_1 = caculte_len(_s);
   //  由于以上 _k 中的 "aaaaa" 所有权发生转移,给了新变量 _kk，也就是说 _k 会被drop销毁，此时下面的执行的打印会报错会报错
   println!("the old k is  {_k}");
   //  由于以上 _s 中的 "aaaaa" 所有权发生转移,给了 caculte_len 函数中的入参 s，故而 _s 会被drop销毁，此时下面的执行的打印会报错
   println!("the string {_s} length is {_len_1}");

}

fn caculte_len(s:String) -> usize {
   return  s.len();
}

```


## 2. 利用`借用 (Borrow)`避免所有权的转移

为了解决以上变量在使用过程中的所有权的随意变动而导致的不方便，在 rust 中有了 `借用 borrow` 机制，即 符号 `&`.

当你`借用`某个值时，实际发生的变化是：
`栈上的指针`：借用时，栈上的指针会被传递给借用者，而不是堆数据本身。
`堆上的数据`：堆数据本身不会发生任何变化，它保持不变，借用者只能通过指针来访问它。

简单来说在 Rust 中，借用是通过引用来实现的。
`借用并不会复制堆上的数据`，也不会移动车辆的所有权，而是通过一个创建一个新的 `指针` 来访问已有的数据。这个指针指向原始数据，依然共享对同一块内存的访问。

或者还有一种额外的方式，就是直接 `clone` 复制对应的值,
`clone` 会 深拷贝 堆上的数据，并返回一个新的所有者。
它不仅复制栈上的指针（如所有权转移时），还会复制堆上的数据。
因此，调用 `clone` 时，会生成一个新的独立的对象，原始对象和克隆对象拥有各自的所有权，互不干扰。


```rust

fn main() {
   
   let _s: String =  String::from("aaaaa");
   // 下面的 _ss 只是借用于 _s, 也就是只是创建了一个新的指针从堆上的原数据指向栈上的新变量 _ss, 
   // 同时旧的指针和所有权并未发生改变，此时内存上的 "aaaaa" 的所有权仍然属于 _s
   let _ss:&str = &_s;
   println!("the borrow string is {_ss}, and old string is still {_s}");

   // 以下的拷贝行为是通过完全复制原来的数据,同时在栈上创建新的指针的同时,在堆上开辟了新的地址来存储复制过来的 "aaaaa"
   let _sss:String = _s.clone();
   println!("the clone string is {_sss} , and it clone from {_s}");

}

```



## 3. 函数之间的变量的 scope 是相互隔离的

简单来说, 相互隔离的 scope ,或者说,当变量的 owner 已经`out of scope` 时, 在`rust`中原来的变量会被 `drop` 掉

```rust

fn main() {   
   let _s: String =  String::from("aaaaa");

}

fn print_lost() {
   //  下面会报错 not found in this scope ,因为函数之间的变量本身就是隔离的,
   //  换句话说，因为相对于 main 中的 _s ， 由于此时已经 out of the scope, 
   //  故而在当前的 scope下面, _s 已经被 drop 销毁了， 所以下面的引用会报错    
   println!("the borrow is {}", &_s)
}


``