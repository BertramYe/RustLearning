
# 简单介绍


下面主要是关于 `结构体（struct）`，`实现 (implementation)` 以及  `特征 （trait）` 和 `组合（Composition）` 相关的使用的说明



# 一些实际的例子的使用

## 1.  `结构体（struct）` 一些常用的技巧和方法

`结构体 （struct）` 是一种可以让你将多个变量放在同一指定组名内的一种数据结构，它在 Rust 中扮演者非常重要的角色，
Rust 的结构体类似于其他语言中的类（Class），但结构体本身并不直接定义行为（方法），它只是数据的集合。

同时这种数据结构在 `C/C++` 中也都有定义。

### a. 普通常用的 `Struct 结构体`

```rust

fn main() {
    #[derive(Debug)]   // 允许调试打印 BankAccount 这个 struct
    struct  BankAccount {
        owner:String,
        balance:f64,
        description:String
    }
    //  对于上面定义的结构体，我们完全可以直接这么使用
    //  1. 作为我们的类型检查使用
    //  为了能在后面的修改，此处需要定义为一个 mut 类型的对象实例
    let mut account :BankAccount = BankAccount {
        owner:String::from("Bertram"),
        balance: 150.0,
        description:"this is BankAccount of Bertram".to_string(),
    };

    // 修改里面的值
    account.balance = 130.0;
    account.owner = "BertramYe".to_string();

    // 下面之所以能够正常打印是因为上面的 struct 上添加了 #[derive(Debug)] , 表示允许调试打印
    println!("current account details is {account:?}"); // 打印： current account details is BankAccount { owner: "BertramYe", balance: 130.0, description: "this is BankAccount of Bertram" }

    // 2. 除了以上的修改，还可以这么干，直接进行析构创建
    //  在这一点和 nodejs  中的对象语法非常相似
    let BankAccount { description, .. } = account; // 这里和 js 很相似，可以直接析构
    let new_account = BankAccount{
        owner:"Bertram".to_string(),
        description,
        ..account  // 这一个解析一定要放在最后面，这代表，除了以上提供的 owner 和 description 字段，其他的剩下的字段复用原来 account 字段中剩下的字段，而在js语法中，它会直接覆盖，这一点有所不同
    };

    println!("current new_account details is {new_account:?}"); // 打印： current new_account details is BankAccount { owner: "Jim", balance: 130.0, description: "this is BankAccount of Bertram" }
}

```
### b. `单元结构体(Unit-Like Struct)`

Rust 中有一个特殊的类型叫做 `unit type：()`，表示`“空值”`或`“无返回值”`，有点像其他语言里的 `void` 或`空元组`。

同时之所以为了使用 `单元结构体(Unit-Like Struct)` 来定义结构体，此时可以类比为，其他面向对象语言里面的没有初始化参数和属性值的 `类 class`, 
有些`类`在定义和使用时，我们只想要里面添加对应的方法，此时对于有些结构体，当我们只想定义一些实现方法时，
而无任何属性和字段需要添加时，此时我们可以定义一个`单元结构体(Unit-Like Struct)`。

而 `unit-like struct` 的行为就很像这个 `unit type`：
 - 它没有任何数据。
 - 它的所有实例都是完全一样的（因为根本没有字段来区分）。
 - 它在内存中不占空间,因为结构体中没有任何变量和值需要存储，所以内存的消耗为 0 字节。
 - 作为标记（marker type）：常用于泛型或 trait 系统中，只用来表示某种行为或角色，而不需要存储任何实际数据。


```rust
// 定义一个 unit-like struct， 里面没有任何属性和字段
struct Logger;

//  实现这个结构体时，只有 log 方法
impl Logger {
    fn log(&self, msg: &str) {
        println!("[LOG]: {}", msg);
    }
}

//  也可以只表示某个角色的占位
struct WriteOnly; // 定义一个 unit-like struct， 里面没有任何属性和字段，只表示是否能被写的角色权限的抽象

fn main() {
    let logger = Logger; // 不需要加括号
    logger.log("Hello from Logger!"); // 打印： [LOG]: Hello from Logger!
}

```


### c. `元组结构体 （Tuple Struct）`

在 Rust 里，除了普通的 `具名字段结构体` 和 `Unit-like 结构体`，还有一种介于两者之间的结构体类型，叫做 `Tuple Struct（元组结构体）`。

它主要有以下几个特点：
  - 没有字段名；
  - 字段类型用圆括号 (...) 按顺序列出；
  - 实例化时也用圆括号；
  - 字段访问靠「index 下标」，而不是名字。


```rust

// 定义两个 `Tuple Struct（元组结构体）`
struct  Color(u8,u8,u8);
struct Point(f32,f32);

fn main() {
    // 初始化以上的对象
    let red = Color(255, 0, 0);
    let p = Point(10.5, 20.3);

    // 访问字段：通过 .0、.1、.2 下标
    // 这里使用占位符，是因为不可以使用 {red.0} 这种写法，会报错的
    println!("Red = ({}, {}, {})", red.0, red.1, red.2); // 打印： Red = (255, 0, 0)
    println!("Point = ({}, {})", p.0, p.1); // 打印： Point = (10.5, 20.3)

}


```

> 补充一下，为什么不用普通元组 (u8,u8,u8);？

确实可以，但元组结构体相比普通元组有这些优势👇

| 普通元组 `(u8, u8, u8)`                  | 元组结构体 `struct Color(u8, u8, u8);` |
| --------------------------------------- | ------------------------------------ |
| 只有类型，没有语义                        | 有一个明确的类型名（如 `Color`）        |
| 不能为元组实现自定义方法                  | 可以为 `Color` 实现方法和 trait         |
| 普通元组之间结构没有区分，能直接相互赋值   | 不同元组结构体是不同类型，即使字段类型相同 |

详细如下：

##### a. 可以防止类型 和 值得胡乱混用

```rust
struct Color(u8, u8, u8);
struct Point(u8, u8, u8);
fn main() {
    let c = Color(255, 0, 0); // 红色
    let p = Point(255, 0, 0); // 某个三维点的坐标

    // 类型不同，不能混用！
    // let x: Point = c; // ❌ 编译错误, 这样可以避免「把红色当坐标用」这种低级错误。
}
```

##### b. 可以像普通结构体一样实现方法

```rust

struct Point(f64, f64);

// 毕竟是结构体的一种，可以实现方法
impl Point {
    fn distance_from_origin(&self) -> f64 {
        (self.0.powi(2) + self.1.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point(3.0, 4.0);
    println!("Distance: {}", p.distance_from_origin()); // 5.0
}

```

##### c. 也支持解构（Destructuring）


```rust
// 定义元组结构体
struct Point(f64, f64);

fn main() {
    let p = Point(1.0, 2.0);
    // 你可以直接把元组结构体拆成变量：这和普通析构类似，对比 js 中的对象 和 array
    let Point(x, y) = p;

    println!("x = {}, y = {}", x, y);
}

```


## 2. `实现 (implementation)` 


`实现 (implementation)`，在 Rust 中使用关键字`impl`, 它是用来为结构体定义方法（行为）的地方。
通过 impl 关键字，可以为结构体定义`关联函数（不需要实例化结构体的函数`）和`方法（需要实例化结构体的函数）`。

在实际使用中，可以简单将 `结构体（struct）` 和 `实现 (implementation)` 结合一并看成是其他`面向对象 OOP 语言`中的 `类（class）` 使用。

```rust


fn main() {   
   
   // 这里之所以定义   account 为 mut 是因为我们在后面调用了 widthdraw 方法，因为它会修改 account 里面的值，所以这里必须写成 nut
   // 如果 你在后面只调用了 check_account 函数，由于它没有对 account 里面的对象进行修改，此时可以不将 account 定义为一个 mut 对象
    let mut  account = BankAccount{
        owner:"Bertram".to_string(),
        balance:150.0
    };
    account.check_account();
    account.widthdraw(10.0);
    account.check_account();

}



struct  BankAccount {
    owner:String,
    balance:f64,
}


// 在定义实现中吗，其内函数不能重名，因为在 rust 里面没有 override 概念，这和 C# 是不相同的
impl BankAccount {
    
    // 这里面必须是 &mut self， 因为你在修改 BankAccount 中的 balance 值，所以此时需要将 BankAccount 变成 mut 类型的 结构体 Struct
    fn widthdraw(&mut self,money:f64){
        self.balance  -= money;
        println!("withdrawed {money}")
    }

    // 注意下面之所以没有使用 &self 是因为在 check_account 函数中，并没有进行对 BankAccount 中的值进行修改行为
    fn check_account (&self){
        let current_owner = self.owner.to_string();
        let current_balance = self.balance;
        println!("current account owner is {current_owner}, balance is {current_balance}")
    }

}


```


## 3. 关于利用 `特征 （trait）` 来实现 结构体的 `继承和多态`

> 首先需要明确一点，在 `Rust` 中没有面向对象编程中的`继承`模型，但是，你可以使用`特征 (trait)`来实现接口式的多态，通过 trait 和 impl 来共享行为。
同时 Rust 中的`特征（trait）`支持继承，通过特征继承可以实现类似接口继承的功能。

其中， `Rust 的特征（trait）` 类似于其他语言中的接口或抽象类，它允许定义方法签名并让结构体实现这些方法。
通过特征，你可以为多个结构体提供共享的行为。虽然这不是真正的继承，但它提供了一种类似的多态机制。

同时需要注意的是，在 Rust 中，`trait` 主要用于定义 `方法的抽象`，它允许我们指定一个类型`必须实现哪些方法`。
然而，`trait 中 不能直接定义字段（属性）`，它`只能定义方法的签名`。
而对于属性而言，应该定义在 ` 结构体 struct ` 里面，它是对属性的抽象。


```rust

fn main() {   
   
   let dog = Dog{
    name: "Jim".to_string()
   };
   let cat = Cat{
    name: "Tom".to_string()
   };

   dog.bark();
   cat.bark();

}


// 先提取 Dog 和 Cat 都有的共同特征 那就是都会叫 （bark）
// 这样，通过特征 trait，我们可以让不同的结构体共享相同的方法。
trait Barking {
    fn bark(&self); // 只能定义方法的签名
}

struct Dog {
    name: String,
}

struct Cat {
    name: String,
}

// 在下面 impl 中的 for 关键字，它是 实现 trait 的语法部分。
// 通过 impl 和 for，你可以指定某个类型（如结构体、枚举或其它类型）如何实现特定的 trait。
impl Barking for Dog {
    fn bark(&self) {
        println!("the dog of {} bark as Woof!", self.name);
    }
}

impl Barking for Cat {
    fn bark(&self) {
        println!("the cat of {} bark as Meow!", self.name);
    }
}


```

除了以上，还可以有下面有意思的代码，为当前 Rust 所默认的 类型拓展方法

```rust

trait Addable {
    // 注意这里面的 add 携带了 self ，所以它是个实例方法，而不是静态方法
    fn add(&self, other: &Self) -> Self;
}

impl Addable for i32 {
    fn add(&self, other: &Self) -> Self {
        self + other
    }
}

impl Addable for f64 {
    fn add(&self, other: &Self) -> Self {
        self + other
    }
}

fn main() {
    // 对于以上的代码而言
    // impl Addable for i32 和 impl Addable for f64 分别为 i32 和 f64 类型实现了 Addable 这个 trait。使得对于 默认的 类型 f64 和 i32 都有一个 add 方法
    // 泛型实现可以通过多个类型共享相同的行为，add 方法的具体实现依赖于具体的类型。
    
    let int_sum = 10.add(&5);  // 使用 Addable 为 i32 实现的 add, 这里的 10 隐式的代替了 i32
    // 需要注意的是，对于上面的奇怪的写法是因为 在 Rust 中，基本类型如 i32 和 f64 并不需要显式创建实例。
    // 你可以直接对字面量（如 10）调用方法。Rust 自动为这些字面量创建引用，使得调用方法变得非常简洁。
    // 其本质等价于下面这样：
    // let int_sum = (&10).add(&5);  // 首先创建对 10 作为 i32 类型的引用
    // let int_sum = Addable::add(&10, &5); // 继续调用 trait 的实例方法

    //  同时不能像下面这么调用，这是因为 Addable{}.add(&10, &5) 这样的写法不会有效，因为它是 错误的语法，无法实例化 Addable trait。
    //  Addable 是一个 trait，而不是一个结构体 struct，因此不能像 Addable{} 这样实例化。  
    // let int_sum = Addable{}.add(&10, &5);
    
    
    let float_sum = 10.5.add(&5.5);  // 使用 Addable 为 f64 实现的 add
    
    println!("int sum: {}", int_sum);  // 输出：int sum: 15
    println!("float sum: {}", float_sum);  // 输出：float sum: 16
}


```

对于上面的例子，需要注意和解释一下下面几点：

a. `::` 语法的作用:

在 Rust 中，`::` 主要用于以下几种情况：

 - 静态方法的调用：比如调用结构体或枚举的关联函数（如 new、parse 等）。
 - 类型名访问：例如访问类型的关联常量、枚举变体等。
 - `trait`的关联方法：通过 `:: `来调用 `trait` 中定义的`静态方法`或`实例方法`。

b. 如何理解 `10.add(&5)` 和 `Addable::add(&10, &5)`

首先，由于 `add` 方法中的入参是含有 `&self`,即自身`特征`的入参，所以 `add` 方法是 `特征Addable` 中的`实例方法`，它有一个 `&self` 参数，意味着它是依赖于`实例`的。

但为什么 `Rust` 使用 `::` 来调用它，而不直接使用 `.` 来像调用 `结构体 struct` 实例化出来的对象一样 调用`add` 方法呢？

首先来看下面的两种写法：
 - `10.add(&5)`：这里 `10` 是 `i32` 类型的字面量。`Rust` 会自动把字面量 `10` 转换成引用 `&10`，并使用 `Addable trait` 为 `i32` 类型提供的 `add` 方法。
这看起来像是通过 `实例方法` 来调用 `add`，但背后实际上会被 Rust 自动解析为 `Addable::add(&10, &5)`。
 - `Addable::add(&10, &5)`：这种写法显式地调用了 `Addable trait` 中定义的 `add` 方法。通过 `::` 来指定 `Addable trait`，并手动传递 `&10` 和 `&5`。

这两种写法等价，Rust 自动将 `10.add(&5)` 转换成 `Addable::add(&10, &5)`。

c. 为何 `Rust` 使用 `::` 进行方法调用 ？

虽然 `add` 是一个 实例方法，但你在 `10.add(&5)` 中调用的是 `trait` 中定义的`实例方法`。`Rust` 允许通过 `trait` 的实现 来实现方法的调用，而不会强制要求你使用 `Addable` 来显式调用该方法。这个机制是 `Rust` 语法的一个简化。

d. 为什么不直接使用 `.` 来调用呢 ？

原因在于 `Rust` 使用 `.` 来调用 `实例方法`,或者说是 `结构体 struct` 实例化出来的方法，而 `::` 用来调用 `trait` 的方法（包括实例方法）。
所以，尽管 `add` 是实例方法，它实际上是通过 `Addable trait` 实现的，因此 `Rust` 使用 `::` 来解析。

你可能认为 `add` 应该是一个普通的实例方法，直接使用 `.` 来调用，但 `Rust` 的设计允许 `trait` 方法 被看作是 `类型的方法`。
由于 `Addable trait` 的 `add` 方法是为 `i32` 和 `f64` 类型分别实现的，`Rust` 会通过 `trait` 的实现来调用它，这就导致了你看到的 `::` 语法。

总之，在 Rust 中，`方法`（包括 trait 实现的方法）是和`类型关联的 (静态方法，即入参不带 self 的方法)`。当你调用 `10.add(&5)` 时，`Rust` 自动推导出它需要使用 `Addable::add(&10, &5)` 来进行方法调用。这种写法隐式地使用了 `::` 来查找对应的 `trait` 方法，因此不需要你手动写出 `Addable::add`。

## 4. `组合（Composition）`

> `组合（Composition）` 和 类中的多态（Polymorphism）都是面向对象编程（OOP）中的重要概念，它们都帮助我们设计灵活和可扩展的代码，但它们在概念和实现上有一些关键区别，
尤其是在 `Rust（强调组合而非继承）`和传统的面向对象语言（如 Java、C++）中。

`组合`是一种设计原则，强调通过将多个小的、独立的对象组合在一起，来构建一个更复杂的对象。
在 `Rust` 中，`组合`的核心是 `结构体`的组合，即一个结构体包含其他结构体作为其字段，形成一种 `has-a` 关系,（例如，一个车有一个引擎）。

同时在下面的例子中也可以看出，对于同一个 结构体 Car， 也可以使用 imp 关键字对其具体的方法或者属性的实现，进行多次，
这在一定程度上极大的方便了对结构体自身的可拓展性和以后新功能的添加。

```rust

struct Engine {
    horsepower: u32, // 引擎中有一个属性 horsepower 定义了引擎的马力值
}

//  新的结构体 Car 将 Engine 结构体组合起来
struct Car {
    make: String,
    engine: Engine,  // 组合：Car 拥有 Engine
}

// 可以使用 impl 对结构体进行多种方法和静态常量属性的实现
impl Car {
    const MAX_SPEED: u32 = 240; // 静态常量
}

impl Car {
    // 实现这个 Car 结构体，其中定义了一个 new 方法，帮助创建一个 新的 Car 对象
    // 之所以这个 _new 加下划线，表示这个方法在后面可能不调用，防止编译有 未使用的 warning: `#[warn(dead_code)]` on by default
    //  由于这里面的 _new 方法没有传入 &self 的引用，所以下面的 _new 的实现属于 结构体 Car 的静态方法， 或者称为关联方法。
    fn _new(make: String, horsepower: u32) -> Car {
        return Car {
            make,
            engine: Engine { horsepower },
        };
        
        // 注意上面的 Ruturn 也可以像下面这样省略
        // 同时需要注意，当省略了 return 后，下面的默认返回的最后一定不要携带 分号 ; ,  
        // 否则最后的分号会导致 Rust 将 下面 Car 的创建语句视为一个普通的语句，并返回 (), 注意此时返回的 () 不是tuple，而是单元类型，而不会返回 Car 实例化的对象，从而报错。
        // 但是上面如果使用了 return 关键字时，结尾最好要要携带分号，当然由于是代码块的最后一行，以上的 return 也可以不携带 分号。
        // Car{
        //     make,
        //     engine: Engine { horsepower },
        // }
    }
}


impl Car {
    // 同时这个结构体有一个 print_details 的方法
    fn print_details(&self) {
        println!("Make: {}, Horsepower: {}", self.make, self.engine.horsepower);
    }
}


fn main() {
    // :: 用于调用结构体、枚举或 trait 中定义的 静态方法（即 关联函数）。这些函数通常不需要通过实例化对象来调用，而是通过类型本身进行调用。
    // 这一点有点类似 php 的类的静态调用，同时需要注意的是，PHP 中的 Trait 是一种代码复用机制，它允许多个类共享相同的方法，但并不涉及实例化行为。
    // 但是它们的 Trait 都不能定义属性，它们只包含方法实现。Rust 的 Trait 是强类型的，并且是 行为的抽象，而 PHP 的 Trait 更侧重于代码的复用。
    let car = Car::_new(String::from("Toyota"), 200);
    
    // 相比较于上面，也可以像下面这么写，注意在实际使用中的 Car 实现的其实本质上还是 结构体
    // let car = Car{
    //         make: "Toyota".to_string(),
    //         engine: Engine{horsepower: 200}
    //     };
    
    // Car::MAX_SPEED 使用 :: 来访问结构体 Car 中的关联常量 MAX_SPEED (也就是静态常量)
    // 注意，对于 Rust 结构体中的静态常量或者方法的访问只能使用 ：： 符号   
    let car_max_speed = Car::MAX_SPEED;

    println!("cars' max speed is {car_max_speed}"); // 输出：cars' max speed is 240
    car.print_details();  // 输出：Make: Toyota, Horsepower: 200
}

```


# 一些总结

总之一句话， 在Rust中 `特征 trait`和 `结构体 struct `分别是对某个对象的`方法 fn`和`属性`的`类型抽象`，
而具体的`实现`还需要借助 `impl 关键字`来实现这些抽象的概念和将对应的`特征`和`方法`进行`组合(Composition)`,从而形成复杂且满足需求的`对象`。

下面是对以上种种相结合的一个例子：

```rust

trait Barking {
    fn bark(&self); // 特征 Barking 抽象出了一个 bark 方法
}

struct Dog {
    name: String,
}

struct Engine {
    horsepower: u32,
}

struct Car {
    maker: String,
    engine: Engine,
    barker: Box<dyn Barking>,  // 组合并实现多态
}

// 为 Dog实现 Barking 特征中的 bark 方法
impl Barking for Dog {
    fn bark(&self) {
        println!("{} says Woof!", self.name);
    }
}

impl Car {
    // 没有 self 的 静态方法
    fn new(make: String, horsepower: u32, barker: Box<dyn Barking>) -> Car {
        
        // 由于此时下面省略了关键字 return， 所以结尾一定不能添加分号 ； ， 
        // 否则会被 Rust 看成是 普通语句，并返回 (), 注意此时返回的 () 不是tuple，而是单元类型，而不会返回 Car 实例化的对象，从而报错。
        Car {
            maker:make,
            engine: Engine { horsepower },
            barker,  // 这里可以像js 一样，往对象里面传参
        } 
    }

    // 这是实例化方法，有 &self 入参
    fn play_sound(&self) {
        println!("{} maked the {}'s housepower car",self.maker,self.engine.horsepower);
        self.barker.bark();
    }
}

fn main() {
    let dog = Dog { name: String::from("Buddy") };
    // 先狗吠
    dog.bark(); // 输出 Buddy says Woof!
    // 注意对于下面的 Car 由于在实例化时，直接入参了 dog 对象，
    // 所以在下面的 函数执行完时，dog 会被drop掉，这是因为 下面的new在调用时,入参dog 会导致 dog 的所有权ownership发生变动,所以会被销毁。 
    let car = Car::new(String::from("Toyota"), 200, Box::new(dog));
    // 再卡车声浪
    car.play_sound();  // 输出：Toyota maked the 200's housepower car  和 Buddy says Woof!
}


```
