
# 简单说明一下

在 Rust 中 的 `Borrow` 和 `Reference` 是两个很重要的概念


# 1. Borrow（借用）

`Borrowing` 是指对一个值的借用，允许你通过引用来访问数据。借用有两种类型：

 - `Immutable borrow（不可变借用）`：允许你读取数据，但不允许修改。
 - `Mutable borrow（可变借用）`：允许你修改数据，但在同一时间只能有一个可变借用，且不能同时有不可变借用存在。

借用是通过 `引用` 实现的，Rust 中不直接暴露借用的语法，但你在使用`引用`时实际上就是在`借用`数据。

> `借用的本质是对某个数据的“临时访问权限”`，而这种权限是有限的，不会改变数据的所有权。
> 在借用时，Rust 确保借用过程中不会发生数据竞争或内存访问错误。

```rust

// 在下面的例子中，r 是对 s 的一个借用，我们通过引用 &s 借用了 s 的内容。
let s = String::from("hello");
let r = &s; // 不可变借用
println!("{}", r);

```

# 2. Reference（引用）

`Reference` 是 Rust 中的一个具体类型，表示对某个值的`指针`。它是对变量的借用，是通过 `&` 或 `&mut` 来创建的。
`引用`是一个指向某个值的借用（借用意味着你借用了数据的访问权，而不是拥有数据）。
`引用本身不拥有它所指向的数据，它不会转移数据的所有权`。Rust 的借用检查器确保引用的生命周期和有效性。

  - `Immutable reference（不可变引用）`：`&T`，允许读取数据，但不能修改。

  - `Mutable reference（可变引用）`：`&mut T`，允许修改数据。

`Reference` 是借用的具体形式，它决定了你对数据的`访问权限（读/写）`。


```rust

let s = String::from("hello");
let r1 = &s;  // 不可变引用
let r2 = &s;  // 另一个不可变引用
println!("{}", r1);  // 可以同时拥有多个不可变引用

let mut s2 = String::from("world");
let r3 = &mut s2;  // 可变引用
r3.push_str("!");
println!("{}", r3);


```

简单总结如下：

- `Borrow` 是一种概念，表示对数据的`借用`，不会修改数据的所有权。

- `Reference` 是实现借用的具体类型，它是对某个值的`引用`。

> 借用时使用引用，而引用则通过 `&` 和 `&mut` 来标识数据是`不可变借用`还是`可变借用`.

> 所以其核心一点就是 : `借用 是 Rust 中对数据访问权限的管理，它是一个更广泛的概念。引用是借用的语法和具体实现。`


```rust

fn main() {   
    let s = String::from("hello");
    let r1 = &s;  // 不可变引用
    let r2 = &r1;  // 另一个不可变引用
    let r3 = &&s;  // 另一个不可变引用,这里面是多次借用，相当于创建了两个指针，同时从堆上的数据
    println!("r1: {}", r1);  // 可以同时拥有多个不可变引用
    println!("r2: {}", r2);  // 可以同时拥有多个不可变引用
    println!("r3: {}", r3);  // 可以同时拥有多个不可变引用

    let mut s2 = String::from("world");
    let r4 = &mut s2;  // 可变引用
    r4.push_str("!");
    println!("{}", r4);
}

```

以上简单来说就是：
  1. s 是一个 所有权 为当前作用域的变量，它持有一个指向堆内存的指针，包含了 "hello" 字符串,它是栈上的一个变量，大小已知且固定。
  2. r1 是对 s 的一个 不可变引用，它存储的是一个指向 s 所有数据的指针 (r1 本身存储的是栈上 s 的内存地址。r1 只是栈上 s 数据的指针)，但是这个引用并不会改变 s 本身。
  3. r1 只是一个指向 s 数据的指针，所以你可以通过 r1 来访问 s 中的内容，但不能修改 s，因为它是一个不可变引用。
  4. 这种借用不会改变 s 的所有权，也不会移动数据。数据依然存储在 s 中，而 r1 只是一个“借用”它的引用。
  5. &&s 是对 &s 的不可变借用，它存储的是指向 &s 的指针，也就是说，r3 现在是一个指向栈上 &s 的引用。
> 你可以把这个过程想象成：
 - s 是原始的箱子，里面放着 "hello"。
 - r1 是一个标签，指向这个箱子，但这个标签本身并不拥有箱子。
 - r2 是指向 r1 标签的另一个标签。因此，在内存层面上，`借用（&s）只是让 r1 成为 s 数据的指针，而不是“将指针从 s 指向 r1”`，因为 `s 仍然拥有数据的所有权，r1 只是对数据的访问权限`。



- `栈上数据（如基本类型）` 在借用时并不会改变其内存位置，引用只是对数据的访问指针。
- `堆上数据（如 String、Vec 等）` 也不会在借用时改变其内存位置，借用（不可变或可变引用）只是在栈上创建了对堆数据的访问指针。
- `可变借用`时，如果有多个引用，它们的修改会直接影响堆上的数据内容，但栈上的引用本身并不会引起内存位置的变化。

- 在 `借用` 的过程中，`借用`的是数据的`引用`，而不是数据本身的移动。`Rust`的所有权和借用机制确保了在对堆数据进行借用时不会发生`悬挂指针`或`数据竞争`的问题。

补充一点关于`悬挂指针`如下：

`悬挂指针（Dangling Pointer）`是指一个指针指向的内存位置已经被释放或不再有效的情况。简单来说，悬挂指针是一个指向已释放内存的指针。
当你尝试通过一个悬挂指针访问已释放的内存时，可能会引发未定义行为、崩溃或程序错误。


# 3. Pointer （指针）

`指针 (Pointer)` : `它是一个内存地址，指向存储在该地址的数据`。指针拥有数据的所有权并且可以直接操作数据。故而它和 `引用 (Reference)`是完全不同的.
Rust 中的指针包括`裸指针（*const T 和 *mut T）`和`智能指针（如 Box<T>、Rc<T> 和 Arc<T>）`。

## Raw Pointers (裸指针)

`裸指针（Raw Pointers）`: 在rust中使用 *const T 和 *mut T 来进行类型标注，它可以自由地指向任何地方，并且你可以选择是否改变它们所指向的值。
它们不具有 Rust 引用的生命周期和借用规则，因此可能更危险。
你可以直接操作裸指针所指向的数据，无需借用检查器的限制。

换句话说，`裸指针（Raw Pointers）` 在 Rust 中是通过 `*const T` 或 `*mut T` 类型显式声明的指针。
这些指针不遵循 Rust 的所有权和借用规则，因此它们不能自动进行生命周期检查。
裸指针不由 Rust 的借用检查器管理，使用时需要 unsafe 代码块来保证安全。

> 需要注意的是： 
裸指针可以是 null （Rust 提供了 std::ptr::null() 和 std::ptr::null_mut() 来创建一个 null 裸指针），但它并不会自动变成悬挂指针（dangling pointer）。
悬挂指针 是指指向已经被释放的内存的指针，通常在内存已经释放之后，指针仍然存在，导致你访问无效内存。而 null 指针并不指向任何有效的内存，因此它本身并不是悬挂指针。
但是，访问`空指针（null）`会导致错误，这和悬挂指针有一些相似之处。虽然裸指针可以是 null，但如果你试图解引用一个 null 指针，会导致 未定义行为，这是 Rust 中最危险的部分之一。

```rust
// 以下是两个 为 null 的裸指针
let null_ptr: *const i32 = std::ptr::null();  // 为 null 的 不可变裸指针（immutable raw pointer）
let null_mut_ptr: *mut i32 = std::ptr::null_mut();  // 为 null 的 可变裸指针（mutable raw pointer）
```

> 总之，裸指针的值可以为 null，并且 Rust 并不强制你检查裸指针的有效性。在需要时，你可以显式地处理 null 指针。
> 但是，裸指针本身可以为 null，并不会自动变成悬挂指针，除非它指向已经被释放的内存。


```rust

fn main() {   
    let mut x = 5;
    // 注意下面 &mut x 是一个 引用，它属于 Rust 的所有权系统，它会自动管理生命周期，防止悬挂指针或引用失效。
    // 引用总是被借用检查器和生命周期检查器管理，因此不能像下面的裸指针p那样直接操作内存。
    // 需要注意的是一下，裸指针是 p，而 *p 只是对裸指针 p 进行的解引用 (Dereferencing) 操作， 它用来访问裸指针p指向的值， 同时 *mut i32 只是对 p 的类型标注
    let p: *mut i32 = &mut x;  // 可变裸指针 p
    unsafe {
        *p = 10;  // 通过裸指针修改数据
                  // 在这里，*p 解引用了裸指针 p，并修改了 x 的值为 10, 其实在 Rust 中， *p 就是对变量 p 的解引用
    };
    unsafe  {
        println!("the value of the p points to: {}",*p); // 解引用裸指针，打印它指向的值
    }
}


```