

# 简单描述

这里只是对 `Rust` 的变量做一下简单的记录
对于 `rust` 的变量的定义, 基本使用上主要常见的是以下几种：

- `let` 关键字定义的变量：即`局部变量`，Rust 对其引用的规则与 `static mut` 有很大的不同。具体来说，`let `定义的变量没有 `static mut` 变量那么严格的约束，但依然有一些关于 `不可变引用（&T）` 和 `可变引用（&mut T）` 的规则, 同时 `let` 一般常在局部结构，如`函数体`, `代码块` 等局部使用，它一般不可以直接 比如在 `main` 外部直接定义变脸，否则编译时可能会报错， 因为外部此时应该使用 `const` 来定义常量使用。

- `const` 关键字定义的常量：常量在编译时就会被替换为其值，并且是不可变的。它不存储在特定的内存地址上，而是直接被内联到代码中。换句话说，const 并不会创建一个实际的内存位置来存储它的值，它的值在编译期间直接嵌入到程序中。`const` 的生命周期是 `'static`，但是它的值并不存储在栈或堆中，而是嵌入代码中。`const` 在代码中是 `作用域可见` 的。它可以被任何地方引用，作用范围是定义它的那个作用域。

- `static` 关键字定义的变量：`变量`会在程序启动时初始化，并且在整个程序运行期间`一直存在`,常量存储在内存的 `数据段`，占用实际的`内存地址`，因此可能会带来轻微的`性能开销`，但能在多个地方复用这个值,可以使用指针访问到它，`直到程序结束`。`static` 变量是 `全局的`，`其作用范围是整个程序`，在所有函数中都可见（如果是公共的）。如果定义为 `pub static`，则可以在其他模块中访问它。

```rust

fn main() {
    let a = "a";
    #[allow(unused_assignments)] // 注释掉未使用变量的编译报警提示
    let mut  b = "b";  // 位置接使用而在后续重新赋值，可能会有 unused_assignments 报警，此时可以使用下划线跳过未使用变量的提醒,或者使用 #[allow(unused_assignments)] 注释掉未使用变量的编译报警
    b = "B";
    // 虽然 const 定义的 常量可以使用小写的 c 表示，而在实际的编译时也只是报警，但是当在真正使用时，最好使用大写定义常量
    // const c:&str = "c";
    // 虽然以上不报错，但是在以下使用时，最好使用大写 C 来表示
    const C:&str = "c";

    println!("this is the value a: {a},b: {b} , c: {C}"); // 打印： this is the value a: a,b: B , c: c
    // 利用 const 定义的常量可以作用于全局
    println!("the static value TEST_CONST_VALUE is : {TEST_CONST_VALUE}"); // 打印： the static value TEST_CONST_VALUE is : hhhhh
    println!("The static AAA is {AAA}"); // 打印： The static AAA is aaa
    // 使用 unsafe 来访问 _BBB
    // Rust 对 static mut 变量有严格的限制，因为它们可能导致 数据竞争，即多个线程访问同一数据时可能发生的问题。
    // 为了防止这种情况，Rust 规定访问 static mut 变量必须在 unsafe 代码块中进行，要求开发者自己保证安全性, 但是最新语法中，这种做法也是不允许的
    // unsafe {
    //     println!("The static BBB is {_BBB}"); // 会报错，因为可变的静态变量太危险
    // }
}

// 使用 const 定义的常量可以作用于当前局部变量的全局下面，同时const 定义的常量一定要标注其常量类型，否则在Rust中编译时，一定报错
const TEST_CONST_VALUE:&str = "hhhhh"; 
// 其实上面这种使用 cosnt 定义的常量，和下面这种利用 static 定义的常量有点类似，都可以作用于当前全局，但是其存储的地方和生效是不一样的，
// 同时 static 定义的变量可以作用于整个程序的生命周期, 但是由于其目前只定于当前作用域，没有 携带 pub 关键字，所以只作用于当前项目的周期
static AAA:&str= "aaa";
static mut _BBB:&str= "BBBB"; // 虽然可以定义可变的静态变量，但是由于太危险，所以上面的调用会报错

```