
# 简单说明


这里简单记录一下 `Rust` 的逻辑控制， 详细看一下下面的逻辑



# 1. 标准的 `if ... else ...` 逻辑


```rust

#[allow(unused_parens)] // 忽略当前函数的内使用 if 时其条件判断中使用括号造成的警告
fn main() {
    let  a: i32 = 10;
    // 在 rust 逻辑里面，其可以使用括号括号括住 if 的条件，
    // 但是会有警告，可以在当前函数头部使用  #[allow(unused_parens)] 去忽略掉这个警告
    if (a % 3 == 0) {    
        println!(" {a} can be divided by 3")
    }else if a % 2 == 0 {
        println!(" {a} can be divided by 2")
    }else {
        println!("{a} can be divided by some other numbers !")
    }
    // Rust 没有三元表达式， 但是可以有像类似 python 语法相似的 下面的表达式， 因为本质上 {} 可以作为一个带有返回值的 代码块
    let b = if a %3 == 0 {3} else {0};
    println!("the value of the b is {b}");
}

```

# 2. 使用 `match` 关键字


在 一般的编程语言里面，一提到 `if ... else ...` 一定会逃不开 `switch ... case ...` 语法，在很多时候这两个太类似和混用了，
但是在 `rust` 中，没有 `switch ... case ...` 语法，而与之代替的是使用 `match` 关键字创建的语法，这一点和 `Python` 是及其相似的,
但是需要注意的是，在 Rust 种使用 `match`, 不需要使用 关键字 `break` 来断句和退出，对于 `rust` 中的 `break`  主要是用在 循环体中退出。

> 但是需要注意的是， 其 `match` 的返回值的类型一定需要保持一致

```rust



#[allow(unused_parens)] // 忽略当前函数的内使用 match 时其条件判断中使用括号造成的警告
fn main() {
    
    //  没有返回值的逻辑
    let n = 3;
    match (n) {  // 注意： 理论上 Rust 语法上不可以使用 括号包裹 判断 条件 n ， 但是你也可以一样强制添加，但此时需要在 当前函数上添加 #[allow(unused_parens)]  忽略警告
        1 => println!("一"),
        2 => println!("二"),
        3 => println!("三"),
        _ => println!("其他数字"),   // 类似于 default
    };

    let j: i32 = 3;
    let b: &'static str = match j {
        1 => "a",
        // 2 => return "b", // 🔥 当 j 匹配到 这里时 return 直接结束 main 函数, 所以不能这么写，会报错
        2 => "e", // 为了解决上面报错需要这么写
        3 => "c",
        4 => "d",
        _ => "e",
    };

    println!("the value of the b is {b}"); // 打印： the value of the b is c


    // 此时调用 test 函数，合法
    let c: &str = test();
    println!("the value of the c is {c}"); // 打印： the value of the c is 2222

    //  其判断条件可以是多种情况
    let k = 8;
    match k {
        1 | 2 => println!("是 1 或 2"),             // 多个值
        3..=7 => println!("在 3 到 7 之间"),        // 3 ~ 7 区间
        _ => println!("其他"),
    }

}

// 从下面 可以看出此时 return 可以放在 match 里面，但是不推荐，会导致函数直接跳出，导致后面的逻辑无法正常执行
fn test() -> &'static str { // 这里返回类型必须写成 &'static str， 而不能是 &str, 这是因为  match 的每个值的返回类型是 &'static str 
    let j: i32 = 2;
    let b: &'static str = match j {
        1 => "a",
        2 =>  return "2222", // 在自定义分支里面此时可以这么写，因为此时return 只作用于 当前的 test 函数体， 当匹配到这里时，会直接跳出当前 test 函数
        3 => "c", // 这个类型是 &'static str
        4 => "d",  
        _ => "e",  
    };
    //  下面这一行不会被打印，因为当前函数直接在  2 =>  return "b" 跳出，不会走下面任何逻辑
    println!("finished the match");
    // 下面的 return 可以忽略
    // return  b;
    b
}

```