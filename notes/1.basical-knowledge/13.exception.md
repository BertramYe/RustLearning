
# ç®€å•è¯´æ˜

å¯¹äº `Rust` è€Œè¨€ï¼Œå®ƒå¹¶ä¸åƒå…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸€æ ·ï¼Œæ‹¥æœ‰ `try ... catch ...` çš„è¯­æ³•ç»“æ„

å®ƒå¯¹äºé”™è¯¯çš„ `exception` çš„å¤„ç†ï¼Œä¸»è¦å€ŸåŠ©äºå…¶ä¸­å†…ç½®çš„ä¸¤ä¸ª `æšä¸¾ enum` å¯¹è±¡ï¼Œ

é‚£å°±æ˜¯ `Option` å’Œ `Result` , å¯ä»¥è½»æ¾è®©æˆ‘ä»¬å¤„ç†å¯¹åº”çš„æŠ¥é”™å’Œè‡ªå®šä¹‰æŠ¥é”™æœºåˆ¶ï¼Œè¿™æ˜¯å› ä¸ºå¯¹äº `Rust` æœ¬èº«è€Œè¨€ï¼Œ


- é™¤äº†ä¸‹é¢çš„ ä¾‹å­ï¼Œ è¿˜å¯ä»¥å‚è€ƒ å½“å‰ `enum` æ–‡æ¡£é‡Œé¢å…³äº `Option<T>` å’Œ `Result<T, E>` çš„ä½¿ç”¨ä¸¾ä¾‹


å…¶é”™è¯¯ï¼Œç»å¤§å¤šæ•°èƒ½åœ¨ç¼–è¯‘å™¨æ—¶å°±å·²ç»è¢«å‘ç°å’Œéœ€è¦ä½œè€…å¼ºåˆ¶å¤„ç†äº†ï¼Œå…¶è¯¦ç»†å¦‚ä¸‹ï¼š


> `Option<T>`ï¼šè¡¨ç¤ºä¸€ä¸ªå€¼è¦ä¹ˆå­˜åœ¨å¾—åˆ°`Some(T)` çš„è¿è¡Œç»“æœï¼Œè¦ä¹ˆä¸å­˜åœ¨å¾—åˆ° Option é‡Œé¢çš„ `None` å¯¹è±¡ï¼Œç±»æ¯” `typescript` ä¸­çš„ `partial` å…³é”®å­—  

å…¶æºç ä¸­çš„ `emun` ç»“æ„å®šä¹‰å¦‚ä¸‹ï¼š

```rust

// ä¸‹é¢æšä¸¾ï¼Œå…¶ä¸­ T ä»£è¡¨æ³›å‹
enum Option<T> { // ç”¨ Option æ›¿ä»£ nullï¼Œå¼ºåˆ¶ç¼–è¯‘æœŸå¤„ç†ã€Œå€¼å¯èƒ½ä¸ºç©ºã€çš„æƒ…å†µã€‚
    None,   // å¦‚æœä¼ å…¥çš„ç±»å‹ä¸æ˜¯ æˆ‘ä»¬æŒ‡å®šçš„ T æˆ–è€…ä¸ºç©ºå€¼ æ—¶å€™ï¼Œä¼šè¿”å› None å¯¹è±¡
    Some(T),// å¦‚æœä¼ å…¥çš„ç±»å‹ æ˜¯ æˆ‘ä»¬æŒ‡å®šçš„ T å¹¶ä¸”ä¸ä¸ºç©ºå€¼ æ—¶å€™ï¼Œä¼šè¿”å› Some(T) çš„ç»“æœ
}

```

> `Result<T, E>`ï¼šè¡¨ç¤ºä¸€ä¸ªæ“ä½œå¯èƒ½æˆåŠŸï¼ˆOkï¼‰æˆ–å¤±è´¥ï¼ˆErrï¼‰

å…¶æºç ä¸­çš„ `emun` ç»“æ„å®šä¹‰å¦‚ä¸‹ï¼š

```rust

enum Result<T, E> {
    Ok(T),  // æˆåŠŸè¿”å› 
    Err(E),  // å¤±è´¥ï¼ˆErrï¼‰,æˆ–è€…è¯´æ˜¯è‡ªå®šä¹‰çš„ error
}

```


# å®é™…çš„ä½¿ç”¨ä¸¾ä¾‹

åœ¨å®é™…ä½¿ç”¨æ—¶ï¼ŒæŸ¥çœ‹ä¸‹é¢è¿™ä¸¤ä¸ªä¾‹å­å°±æ˜ç™½äº†


## 1. ä½¿ç”¨ `Option <T>` æ¥æ•è·å’Œå¤„ç†æŠ¥é”™

```rust

fn divide_option (a:f64,b:f64) -> Option<f64> {
    if b == 0.0 {
        None // éæ³•çš„ç»“æœï¼Œä¸å…è®¸ è®¡ç®—ï¼Œå¦åˆ™ä¼šæŠ¥é”™
        // å¦‚æœæ­¤æ—¶ä¹Ÿç”¨ Some(a / b) è¿”å›ï¼Œå…¶å¾—åˆ°çš„æ˜¯ Some(inf) ï¼Œè¡¨ç¤º æ— ç©·
    }else {
        Some(a / b)
    }
}

fn main() {
    
    let option_divide_result_1: Option<f64> = divide_option(10.0,0.0);
    println!("option_divide_result_1 : {option_divide_result_1:?} "); // æ‰“å°ï¼š option_divide_result_1 : None 

    let option_divide_result_2: Option<f64> = divide_option(10.0,1.0);
    println!("option_divide_result_2 : {option_divide_result_2:?} "); // æ‰“å°ï¼š option_divide_result_1 : Some(10.0) 
  
    match option_divide_result_1 {
        None => println!("the calculated result is None"),
        Some(s) => print!("the calculated result is {s}")
    }

    // ä»¥ä¸Š match æ‰“å°è¿”å› : the calculated result is None   
}

```


> å¦å¤–è¡¥å……ä¸€ç‚¹, é™¤äº†ä»¥ä¸Šä½¿ç”¨ `if / match` æ¥å¤„ç†å’Œæ•è·é”™è¯¯ï¼Œè¿˜å¯ä»¥åˆ©ç”¨ `?` æ¥ç®€åŒ–é”™è¯¯ä¼ æ’­ï¼Œ
> `Rust` æä¾› `?` æ¥è®© `Result/Option` åƒå…¶ä»–è¯­è¨€çš„å¼‚å¸¸ï¼Œé‚£æ · ä½¿ç”¨ `throw` æ¥è¿›è¡Œ `â€œå†’æ³¡â€`ä¼ æ’­ï¼š

```rust
fn divide_option (a:f64,b:f64) -> Option<f64> {
    if b == 0.0 {
        None // éæ³•çš„ç»“æœï¼Œä¸å…è®¸ è®¡ç®—ï¼Œå¦åˆ™ä¼šæŠ¥é”™
        // å¦‚æœæ­¤æ—¶ä¹Ÿç”¨ Some(a / b) è¿”å›ï¼Œå…¶å¾—åˆ°çš„æ˜¯ Some(inf) ï¼Œè¡¨ç¤º æ— ç©·
    }else {
        Some(a / b)
    }
}


//  è¿™é‡Œæ˜¯ä¸ºäº†ä½“ç° `?` ä¼ é€’é”™è¯¯ä¿¡æ¯é“¾
fn safe_divide_chain() -> Option<f64> {
    let x = divide_option(10.0, 2.0)?; // å¦‚æœ Noneï¼Œæ•´ä¸ªå‡½æ•°ç›´æ¥è¿”å› None
    println!("the x is {x}"); // æ‰“å°: the x is 5;
    let y = divide_option(x, 0.0)?;    // divide_option(x, 0.0) ä¼šè¿”å› None, æ­¤æ—¶ ä½¿ç”¨ ï¼Ÿ ä¼šä¼ é€’é”™è¯¯ï¼Œä¸‹é¢çš„é€»è¾‘å°±ä¸ä¼šè¢«æ‰§è¡Œ
    println!("the y is {y}"); // è¿™ä¸€æ­¥ä¸ä¼šè¢«æ‰§è¡Œï¼Œå› ä¸ºæ­¤æ—¶ y çš„ç»“æœä¸º None
    Some(y)
}

fn main() {
    let result: Option<f64> = safe_divide_chain();
    println!("the result is {result:?}"); // æ‰“å°ï¼š the result is None
    match result {
        Some(v) => println!("Final result: {}", v),
        None => println!("One of the steps failed!"),
    }

    //  ä»¥ä¸Šæ‰§è¡Œç»“æœæ‰“å°ï¼š One of the steps failed!
}


```


## 2. ä½¿ç”¨  `Result<T, E>` æ¥æ•è·å’Œå¤„ç†æŠ¥é”™

```rust

fn divide_result (a:f64,b:f64) -> Result<f64,String> {
     if b == 0.0 {
        Err("can't divide by Zero !".to_string()) // éæ³•çš„ç»“æœï¼Œä¸å…è®¸ è®¡ç®—ï¼Œå¦åˆ™ä¼šæŠ¥é”™
        // Ok(a / b) // å¦‚æœæ­¤æ—¶ä½¿ç”¨ Ok(a / b)  æ—¶ï¼Œä¼šå¾—åˆ° Ok(inf)ï¼Œè¡¨ç¤ºæ— ç©·
    }else {
        Ok(a / b)
    }
}

fn main() {
    let result_divide_result_1: Result<f64,String> = divide_result(10.0,0.0);
    println!("option_divide_result_1 : {result_divide_result_1:?} "); // æ‰“å°ï¼š option_divide_result_1 : Err("can't divide by Zero !")

    let result_divide_result_2: Result<f64,String> = divide_result(10.0,1.0);
    println!("option_divide_result_2 : {result_divide_result_2:?} "); // æ‰“å°ï¼š option_divide_result_2 : Ok(10.0)
  
    match result_divide_result_1 {
        Err(msg) => print!("there were err: {msg}"),
        Ok(s) => print!("the calculated result is {s}")
    }

    // ä»¥ä¸Š match æ‰“å°è¿”å› : there were err: can't divide by Zero !
}

```




## è¡¥å…… Rust çš„ `try { ... }` è¡¨è¾¾å¼ï¼ˆNightly / æœªæ¥ç¨³å®šï¼‰

å½“å‰ `rust` ä¹Ÿæœ‰ ç±»ä¼¼ `try ... catch ...` çš„ææ¡ˆï¼Œé‚£å°±æ˜¯ `try { ... }`, ä½†æ˜¯å®ƒç›®å‰å¹¶ä¸ç¨³å®š

å…¶ä¸»è¦æ˜¯ï¼š ğŸ‘‰ å¦‚æœå…¶ä¸­ä»»æ„ä¸€æ­¥è¿”å› Errï¼Œtry {} ä¼šç«‹å³è¿”å›è¯¥ Errï¼Œå¹¶ä¸æ˜¯ã€Œcatchã€ã€‚

è¯¦ç»†ä¾‹å­å¦‚ä¸‹ï¼š

```rust

fn example() -> Result<i32, String> {
    let x = try {
        let a = some_fallible_op()?;
        let b = another_fallible_op()?;
        a + b
    };
    x
}


```

# ç®€å•æ€»ç»“

å°±ç›®å‰ `Rust` è€Œè¨€ï¼Œå…¶é”™è¯¯å¤„ç†å’Œæ•è·ï¼Œä¼˜å…ˆæ¨èä½¿ç”¨ç›®å‰æˆç†Ÿçš„ `Option<T>` å’Œ `Result<T, E>` æ¥æ•è·å’Œå¤„ç†,

å¯¹äºæœªæ¥ï¼Œå¦‚æœå½“å‰ `try {...}` è¯­æ³•ç¨³å®šæ—¶ï¼Œå¯ä»¥ä¼˜å…ˆä½¿ç”¨å®ƒæ¥è¿›è¡Œ é”™è¯¯çš„æ•è·å’Œå¤„ç†ã€‚

