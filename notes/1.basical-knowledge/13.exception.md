
# 简单说明

对于 `Rust` 而言，它并不像其他编程语言一样，拥有 `try ... catch ...` 的语法结构

它对于错误的 `exception` 的处理，主要借助于其中内置的两个 `枚举 enum` 对象，

那就是 `Option` 和 `Result` , 可以轻松让我们处理对应的报错和自定义报错机制，这是因为对于 `Rust` 本身而言，


- 除了下面的 例子， 还可以参考 当前 `enum` 文档里面关于 `Option<T>` 和 `Result<T, E>` 的使用举例


其错误，绝大多数能在编译器时就已经被发现和需要作者强制处理了，其详细如下：


> `Option<T>`：表示一个值要么存在得到`Some(T)` 的运行结果，要么不存在得到 Option 里面的 `None` 对象，类比 `typescript` 中的 `partial` 关键字  

其源码中的 `emun` 结构定义如下：

```rust

// 下面枚举，其中 T 代表泛型
enum Option<T> { // 用 Option 替代 null，强制编译期处理「值可能为空」的情况。
    None,   // 如果传入的类型不是 我们指定的 T 或者为空值 时候，会返回 None 对象
    Some(T),// 如果传入的类型 是 我们指定的 T 并且不为空值 时候，会返回 Some(T) 的结果
}

```

> `Result<T, E>`：表示一个操作可能成功（Ok）或失败（Err）

其源码中的 `emun` 结构定义如下：

```rust

enum Result<T, E> {
    Ok(T),  // 成功返回 
    Err(E),  // 失败（Err）,或者说是自定义的 error
}

```


# 实际的使用举例

在实际使用时，查看下面这两个例子就明白了


## 1. 使用 `Option <T>` 来捕获和处理报错

```rust

fn divide_option (a:f64,b:f64) -> Option<f64> {
    if b == 0.0 {
        None // 非法的结果，不允许 计算，否则会报错
        // 如果此时也用 Some(a / b) 返回，其得到的是 Some(inf) ，表示 无穷
    }else {
        Some(a / b)
    }
}

fn main() {
    
    let option_divide_result_1: Option<f64> = divide_option(10.0,0.0);
    println!("option_divide_result_1 : {option_divide_result_1:?} "); // 打印： option_divide_result_1 : None 

    let option_divide_result_2: Option<f64> = divide_option(10.0,1.0);
    println!("option_divide_result_2 : {option_divide_result_2:?} "); // 打印： option_divide_result_1 : Some(10.0) 
  
    match option_divide_result_1 {
        None => println!("the calculated result is None"),
        Some(s) => print!("the calculated result is {s}")
    }

    // 以上 match 打印返回 : the calculated result is None   
}

```


> 另外补充一点, 除了以上使用 `if / match` 来处理和捕获错误，还可以利用 `?` 来简化错误传播，
> `Rust` 提供 `?` 来让 `Result/Option` 像其他语言的异常，那样 使用 `throw` 来进行 `“冒泡”`传播：

```rust
fn divide_option (a:f64,b:f64) -> Option<f64> {
    if b == 0.0 {
        None // 非法的结果，不允许 计算，否则会报错
        // 如果此时也用 Some(a / b) 返回，其得到的是 Some(inf) ，表示 无穷
    }else {
        Some(a / b)
    }
}


//  这里是为了体现 `?` 传递错误信息链
fn safe_divide_chain() -> Option<f64> {
    let x = divide_option(10.0, 2.0)?; // 如果 None，整个函数直接返回 None
    println!("the x is {x}"); // 打印: the x is 5;
    let y = divide_option(x, 0.0)?;    // divide_option(x, 0.0) 会返回 None, 此时 使用 ？ 会传递错误，下面的逻辑就不会被执行
    println!("the y is {y}"); // 这一步不会被执行，因为此时 y 的结果为 None
    Some(y)
}

fn main() {
    let result: Option<f64> = safe_divide_chain();
    println!("the result is {result:?}"); // 打印： the result is None
    match result {
        Some(v) => println!("Final result: {}", v),
        None => println!("One of the steps failed!"),
    }

    //  以上执行结果打印： One of the steps failed!
}


```


## 2. 使用  `Result<T, E>` 来捕获和处理报错

```rust

fn divide_result (a:f64,b:f64) -> Result<f64,String> {
     if b == 0.0 {
        Err("can't divide by Zero !".to_string()) // 非法的结果，不允许 计算，否则会报错
        // Ok(a / b) // 如果此时使用 Ok(a / b)  时，会得到 Ok(inf)，表示无穷
    }else {
        Ok(a / b)
    }
}

fn main() {
    let result_divide_result_1: Result<f64,String> = divide_result(10.0,0.0);
    println!("option_divide_result_1 : {result_divide_result_1:?} "); // 打印： option_divide_result_1 : Err("can't divide by Zero !")

    let result_divide_result_2: Result<f64,String> = divide_result(10.0,1.0);
    println!("option_divide_result_2 : {result_divide_result_2:?} "); // 打印： option_divide_result_2 : Ok(10.0)
  
    match result_divide_result_1 {
        Err(msg) => print!("there were err: {msg}"),
        Ok(s) => print!("the calculated result is {s}")
    }

    // 以上 match 打印返回 : there were err: can't divide by Zero !
}

```




## 补充 Rust 的 `try { ... }` 表达式（Nightly / 未来稳定）

当前 `rust` 也有 类似 `try ... catch ...` 的提案，那就是 `try { ... }`, 但是它目前并不稳定

其主要是： 👉 如果其中任意一步返回 Err，try {} 会立即返回该 Err，并不是「catch」。

详细例子如下：

```rust

fn example() -> Result<i32, String> {
    let x = try {
        let a = some_fallible_op()?;
        let b = another_fallible_op()?;
        a + b
    };
    x
}


```

# 简单总结

就目前 `Rust` 而言，其错误处理和捕获，优先推荐使用目前成熟的 `Option<T>` 和 `Result<T, E>` 来捕获和处理,

对于未来，如果当前 `try {...}` 语法稳定时，可以优先使用它来进行 错误的捕获和处理。

