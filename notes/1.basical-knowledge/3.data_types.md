# 简单说明

对于数据结构，基本所有语言都一致，其中，对于 数据结构，以下只是记录一些我平时学习过程中的一些 `rust` 的一些特例而已，
其中如果学过和使用过 `TypeScript` 和 `C#` 基本都类似，基本都大差不差的


>> 一些简单的说明，关于以下所有的测试的打印中，可能会可能到下面特殊的打印符号，可以不用惊讶:
>> - `{}`：默认格式，用于打印基本类型的值（如 i32, f64, bool 等）。
>> - `{:?}`：{:?} 是用于 调试输出格式 的占位符，用来打印实现了 Debug trait 的类型的调试信息。因此，{:?} 并不是一个缩写，而是一个格式标识符，专门用于调试输出。当你想打印复杂类型（如结构体、元组、枚举等）时，使用 {:?} 可以显示它们的详细信息。当然对于简单类型，也可以使用它进行打印。
```rust
   let a = 50;
   println!("number is {a:?}");  // 这行能正常打印，并不会报错
```
>> - `{:#?}`：美化调试输出（会换行并缩进，适用于复杂类型的输出）,简单来说是对 `{:?}` 复杂类型结果打印的一种美化。

# 一、原始类型 (Primitive Types)

详细参考官方文档：https://doc.rust-lang.org/book/ch03-02-data-types.html

对于 `Rust` 的原始数据类型`（Primitive Types）`可以做一下下面的简单归类，

- ✔️ 标量类型（Scalar Types）
    - 整型：i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize
    - 浮点型：f32, f64,....
    - 布尔型：bool
    - 字符型：char

- ✔️ 复合类型（Compound Types）
    - 元组：(T1, T2, ...)
    - 数组：[T; N]

- ✔️ 集合类型 （Collection Types）
    - Vec<T> — 向量（Vector）
    - String / &str — 字符串集合
    - HashMap<K, V> — 哈希映射
    - 除了以上最主要的三个，还有一些其他一些不常用的集合（在 `std::collections` 模块中）,如下：
        - VecDeque<T>：双端队列，前后都可以高效插入/删除
        - LinkedList<T>：双向链表（较少用）
        - BTreeMap<K, V>：基于 B 树的有序映射（键是有序的）
        - BTreeSet<T>：有序集合
        - HashSet<T>：不含重复元素的无序集合

- ✔️ 特殊类型
    - 字符串切片：str（常见为 &str）
    - 单元类型：()（函数无返回值）
    - 发散类型：!（如 panic!、loop {}）

> 注意： rust中的字典类型，被称为 `hashMap`, 它是 `Rust` 标准库中提供的一种 `关联容器`（associative container）, 它因该被理解为一个对象，而不再归类为`Rust`的原始的数据类型 (primitive types)

## A、标量类型（Scalar Types）

详细如下面这段函数， 在 `Rust` 中常常将 `int`,`float`,`bool`,`char` 这四个最基础的数据类型归为标量类型

```rs

fn main() {
    // i 表示正负整数都行
    let a:i32 = 18;
    // 下面这两种打印都可以，rust 中利用 {} 作为占位符，
    // 同时 {a} 只有在 rust 1.58 之后生效,而当前为 1.88.0， 所以后面为了方便，直接全部使用最新语法 {a} 进行打印和占位
    // 另外，以下面的打印为例 {a} 中的变量，"{" 和 a 之间不能有空格，否则编译时会报错，但是 a 和 "}" 之间可以有空格，但是不太美观，不推荐
    println!("this is the int type {}",a);
    println!("this is the int type {a}");
    // 下面这种写法不可以，因为{ a}前面有空格，会报错。
    println!("this is the int type { a}");

    // u 表示所有自然数，也就是非零的整数  
    let b:u32 = 18;
    println!("this is the int type {b}");
    
    // 对于 char 类型，永远只能使用单引号表示，不能使用双引号,因为双引号表示 一段 UTF-8 编码的字符串切片
    // Rust 的单个 char 是 4 字节，支持 Emoji 和非 ASCII 字符,故而对于中文（通常一个中文占用 3 个字节（bytes））也有很好的支持
    let c:char = 'h';
    println!("this is char {c}");

    // 浮点数
    let d:f32 = 0.31;
    println!("this is float {d}");
    // 下面的计算结果 得到的结果为 -0.019999996， 这是因为 计算机的 二进制转换导致的计算精度问题
    // 这个问题在所有语言中都存在，包括 Python, Java,nodejs, c# 等等
    let e:f32 = 0.1 - 0.12;
    println!("this is  count float {e}");
    
    // 布尔值
    let g:bool = false;
    println!("this is the bool value {g}");
}

```



## B、复合类型（Compound Types）


### 1. array 数组

其中对于数组，感觉最重要的也就以下几点

- 同一数组只能保存相同的数组类型
- 普通的固定大小数组（例如 `let array2:[i32;5] = [1,2,3,4,5];`），它们通常存储在`栈（stack）`上。栈是一个 快速 的内存区域，它存储函数的局部变量以及函数调用的返回地址等。
- 动态数组（如 `Vec<T>`）的元素存储在`堆（heap）`上，但是`栈`上还会存储指向`堆`的`指针`。
- Rust 中数组的内存布局是连续的，无论是栈上还是堆上的数组，元素的内存都是紧凑的，不会有额外的间隔。这种内存布局为 `Rust` 提供了高效的性能和内存管理，避免了 `GC（垃圾回收）`和不必要的内存分配。

```rs
fn main() {
    //  可以不定义类型，从而进行隐式定义和转换，注意下面不会报错，同时对于其他类型的数据也是一样的
    let array1= [1,2,3,4,5];
    println!("this is array: {array1:?}");
    // 等价于下面的这种定义方式
    // 其中下面 i32 代表数组类型， 同时 5 代表数组长度或者说 size
    let array2:[i32;5] = [1,2,3,4,5];
    println!("this is array: {array2:?}");

    // 除了上面这个定义，还可以像下面这种进行变相类型定义
    // 简单来说这里 numbers_slice 是一个切片（slice）对象， & 表示“借用(borrow)”，而 i32 是数组元素的类型,同时切片可以不指定切片的长度。
    // Rust 标准库为切片类型（如 &[i32]）实现了 Debug trait，因此可以直接打印切片的内容。{:?} 会打印切片中的所有元素。
    let numbers_slice:&[i32] = &[1,2,3,4,5];
    // 注意，由于切片 slice 是动态的，所以不能像下面这样，指定切片长度为 5 ，这一点和数组 array 是不同的
    // let numbers_slice:&[i32,5] = &[1,2,3,4,5];  // 切片只是 array 的一部分，是动态的，不能指定长度, 所以这行代码会报错
    println!("the numbers of the slice {numbers_slice:?}");

    // 更多有意思的可以参考下面
    //  创建一个存储在 堆(heap) 上的动态字符串 string_temp
    let string_temp:String = String::from("Hello world!");
    // String 类型的 &str 切片是对字符串的一种轻量级引用，&str 是一个不可变的借用，它引用了 String 的一部分或者整个内容，但不会获取所有权。str_ref 是指向 string_temp 的引用。
    // 简单来说 str_ref 是栈上的一个引用（指针），指向堆上的数据 string_temp，同时不指定切片大小 （即借用的堆上的数据的大小， 可以像下面 [0..5] 的索引长度来表示），默认就获取全部
    let str_ref: &str = &string_temp;
    println!("str ref : {str_ref:?}");
    // str_ref 中提取从索引 0 到索引 5 之间的部分（不包括索引 5），即 "Hello"
    // 需要注意的是，Rust 中的切片操作基于字节索引，对于 UTF-8 编码的字符，切片需要遵循有效的字符边界。在这里，"Hello" 中的字符都是有效的字节，所以没有问题。
    let part_str_ref:&str = &str_ref[0..5];
    println!("part str ref : {part_str_ref:?}");
    // 总之, 通过使用切片和引用，Rust 可以避免复制数据，从而提高效率。

    // 通过使用切片和引用，Rust 可以避免复制数据，从而提高效率。
    let chinise_string:String = String::from("这是一段中文！");
    let temp_ch_1:&str = &chinise_string[0..6];  // 这行的打印是 “这是” 
    println!("test for the chinines 1: {temp_ch_1:?}");
    //  下面这个会报错， 因为 一个中文是三个字节。而下面截取的是 0-4，所以会报错
    let temp_ch_2 :&str = &chinise_string[0..5];  // 报错，一个中文占据 3 个字节
    println!("test for the chinines 1: {temp_ch_2:?}");

    // 故此对于字符串，为了解决中英文混合的问题，可以借助 chars 来帮助实现按照
    // chars()：将字符串转换为一个字符迭代器，每次迭代返回一个 char，即一个 Unicode 字符，此时每个 char 大小为 4 字节，足够容纳单个中文的 3 字节长度， 也能够容纳单个英文 1 字节长度，这样就完美解决了中英文混用的切片不准确的问题， 毕竟 3 < 4 而且 1 < 4, 如果有其他语言中的单个 字符串 长于 4 字节，此时需要另外的方式来解决这个问题了
    let chinese_string:&str = "Hello 你好 Rust 世界！";
    // 获取前 6 个字符（不按字节）
    let substring_1: String = chinese_string.chars().take(6).collect(); // 默认从 chars 的索引 0 开始，往后面取 6 位
    println!("substring_1: {substring_1:?}"); // 打印结果为： substring_1: "Hello "
    // 获取字符索引范围从 7 到 14 (即 6 + 9 - 1) 的字符串， 也就是是，首先跳过前 0~5 位字符串 （字符索引从 第 6 位开始），开始往后面数 9 位字符串
    let substring_2: String = chinese_string.chars().skip(6).take(9).collect();
    println!("substring_2: {substring_2:?}"); // 打印结果为： substring_2: "你好 Rust 世"

    // 同时相对而言，根据当前的 Unicode 标准，没有字符的编码超出 4 字节，所以以上方式基本可以通用任何字符串的混合问题。
    // 但是如果你发现某些字符超过 4 字节，可能是由于：
    // - 字符集本身的编码方式（如 UTF-16、UTF-32）。
    // - 其他非标准编码方式或扩展字符集。

    //  在rust中 也可以利用索引获取 array 内的值
    let fist_value = array2[0];
    println!("this is array: {fist_value}");

    // 同时对于 以上打印时需要加上 :? 是因为
    // 默认情况下，Rust 会使用 Display 格式来打印类型，这通常是针对 toString 或 println! 默认打印的方式。
    // 当你打印数组（或其他类型）时，使用 :? 会让 Rust 使用 Debug 格式来输出内容，而不是 Display 格式。
    // Debug 格式则提供了一种用于调试时更详细、更易理解的输出格式。
    // 如果不加 :?，Rust 会尝试用默认的 Display 格式打印数组，但数组类型没有实现 Display，因此会报错。
    // 总结来说，:? 是为了让你在打印调试信息时，看到更清晰、更详细的输出。


    //  另外 array 数组的定义时，在 rust 中一个数组内存储的只能是相同类型的数据，这对于其他的编程语言（如Python）是不一样的
    let aa = [1,'a'];  // 会报错，这是因为 当前数组存储了两个类型数据 int 和 string, 这在 rust中是不允许的


    //  以下简单展示 不同 array 存储的位置
    let vec1 = [1, 2, 3, 4, 5]; // 存储在栈上
    // Vec 是 动态数组 类型，是标准库提供的一个集合类型，用于存储可变长度的元素,可以在运行时增长或缩小，适用于元素数量不确定的情况。
    // 创建一个空的 Vec 可变数组
    let mut dynamic_array = Vec::new(); // 创建一个空的 Vec
    dynamic_array.push(1); // 向 Vec 添加元素
    dynamic_array.push(2);
    dynamic_array.push('jjjj'); // 即便是可变数组，但是仍然需要保证数组内存储的元素的类型一致，故而这行代码会报错。
    
    println!("dynamic array : {dynamic_array:?}");

    // vec! 宏是 Rust 标准库中的宏，允许你在一行代码中创建并初始化一个 Vec。
    let vec2:Vec<i32> = vec![1, 2, 3, 4, 5]; // 存储在堆上
    println!("stack array: {:?}", vec1);
    // 下面这两种打印等价
    println!("stack array: {vec2:?}");
    println!("heap array: {:?}", vec2);
}


```

### 2. tuple 元组

相比较以上的`array`中，同一个`array`只能存储,单一的一种数据类型，为了实现多种不同类型数据的存储，可以使用 `tuple` 元组进行数据存储,同时 `tuple` 默认都是存储在 `stack` 栈上的，即使加了 `mut`, 变成可变 元组，另外，元组 `tuple` 虽然存储不同类型的数据，可能会被误认为其数据存储是在 `堆 (heap)`上，但是由于 Rust编译器会根据每个字段的类型大小和对齐需求来排列这些字段，使得整个结构依然可以连续存储在`栈`上,所以 `tuple` 默认还是会存储在栈`stack`上的 ：

```rs
fn main() {
   // 直接隐式定义一个 tuple 类型
   // 虽然下面存储了不同的数据类型，但是 Rust 编译器会根据每个字段的类型大小和对齐需求来排列这些字段，使得整个结构依然可以连续存储在`栈`上,
   // 所以 `tuple` 默认还是会存储在 栈`stack`上的
   let test_tuple1 = ("qqqq",1,true);
   //  存储在 栈上， 即使加了 mut 变成可变，
   //  这是因为此时 下面的 tuple 的长度依然是固定的， 大小依然是  16 + 4 + 1 + padding
   let mut test_tuple1 = ("qqqq", 1, true);
   //  同时 下面的修改 依然不会导致它从栈迁移到堆, 因为只是改变其存储的内容，并未改变存储的类型，同时大小也并未改变
   test_tuple1.1 = 42;
   test_tuple1.2 = false;
   // 注意下面修改是违法的， 这是因为 tuple 的 第 1 位 在定义时是  int 类型， 你不能将其转化为 char 类型，会报错
   test_tuple1.1 = 'a';
 
   //  显示定义和显示 tuple 类型
   let test_tuple2 :(&str,i32,bool,[i32;5]) = ("aaaa",1234,false,[1,2,3,4,5]);
   //  为了输出显示，一样需要使用 debug 进行打印结果
   println!("test tuple : {test_tuple1:?}");
   println!("test tuple 2: {test_tuple2:?}");
}

```



## C、集合类型 （Collection Types）

`Collection Types（集合类型）` 是一类用来 `存储和管理多个值` 的数据结构，和单个值的 `struct`、`tuple` 或基本类型（如 `i32`、`String`）不同。
集合通常是「动态大小」的，也就是元素的数量可以在运行时增长或缩减（不像数组那样固定长度）。

### 1. `Vec<T>` — 向量（Vector）

它相当于`动态数组`，`可自动扩容`，是使用`最频繁`的集合类型。

它的存储结构其实是 在栈上放一个`「指针+长度+容量」`的三元结构，而真正的数据元素存放在堆上👇

> 编译器在内存里大致会生成这样的结构：

```txt

栈 (Stack)：存储 Vec<T> 的「元数据」
 ┌─────────────┐
 │ ptr ────────┼───┐ 指向堆上已分配内存的指针
 │ len = 3     │   │
 │ cap = 3     │   │
 └─────────────┘   │
                   ▼
堆 (Heap)：真正存放元素的地方
 ┌─────┬─────┬─────┐
 │  1  │  2  │  3  │
 └─────┴─────┴─────┘

```

- `ptr`：指向堆上已分配内存的指针(pointer)
- `len`：当前向量中已存储的元素个数
- `cap`：当前已分配的容量(capability)（还能再放多少元素不用重新分配）

当然，其有一些常用的方法：
  - `push`：添加元素
  - `pop`：移除最后一个元素
  - `len`：获取长度
  - `iter`：遍历
  - `contains`：检查是否包含某值


> 📈 动态扩容时发生什么？

> 当 Vec 需要存更多元素时，Rust 会：
>
>  - 在堆上分配更大的内存块（比如容量翻倍）
>  - 把旧的数据复制过去
>  - 释放旧的内存
>  - 更新 `ptr` 和 cap 元数据
> 
> 这就是为什么频繁 `push` 时，`Vec` 偶尔会发生`「扩容」`。



```rust

fn main() {
    // 创建一个向量 之所以设置为 mut 是因为可以使用 push 向里面推送值
    //  1. 直接借助 new 创建
    let mut numbers: Vec<i32> = Vec::new();
    numbers.push(10);
    numbers.push(20);
    numbers.push(30);
    println!("numbers: {numbers:?}"); //打印： [10, 20, 30]

    // 2. 借助 vec! 宏创建
    let mut new_numbers = vec![1,2,3,4];
    new_numbers.push(4);
    new_numbers.push(5);

    println!("new_numbers: {new_numbers:?}"); //打印： new_numbers: [1, 2, 3, 4, 4, 5]

    // 读取 vec 的值
    //  1. 利用索引读取，比较方便，但是会有 超出数组长度 的风险
    let first = numbers[0]; // 打印: first element: 10
    println!("first element: {}", first);
    // println!("10 th element: {}", numbers[10]); //  报错： index out of bounds: the len is 3 but the index is 10 ，超出数组长度

    // 2. 利用 get 方法读取, 能安全的避免 超出数组长度 的报错， 因为此时当超长时，会自动 返回 None, 比较安全
    // 注意利用 get 方法获取到的是 Option<&i32> 对象，所以，为了获取到指定的值，还需要进一步进行利用 if / match 进行处理
    let new_first: Option<&i32> = new_numbers.get(0);
    let new_secound: Option<&i32> = new_numbers.get(10);
    println!("the new first element: {new_first:?}"); // 打印： the new first element: Some(1)
    println!("the new secound element: {new_secound:?}"); // 打印： the new secound element: None
    match new_first {
        Some(n) => println!("the value we get is {n}"),
        None => print!("the value we get is None")
    }
    //  以上的 match 的打印得到的是： the value we get is 1
}

```

### 2. `String` 字符串集合

注意下面主要解释字符串集合，而不是 `str`, 严格来说，`String` 是一个集合类型，

因为它内部是一个 `Vec<u8>` 的封装，用来存储 `UTF-8` 字节序列, 所以它并没有被写入到 `Rust` 的核心代码中，可以看成是 `Vec<T>`的特例

```rs

fn main() {
        // 对于使用 双引号定义的 字符串，其类型只能指定为 “&str”
        // 这是因为：
        // str 表示的是一段 UTF-8 编码的字符串切片，但它的长度在编译时是未知的。
        // Rust 需要在编译时知道变量的大小（以便正确分配内存和栈空间），而 str 是 不具有已知大小的类型。
        // 所以下面你不能写 let d: str = "hhhhh";，因为编译器无法为 str 类型分配固定大小的内存。
        // "hhhhh" 是一个字符串字面量，它的类型是 &'static str，这是一个指向内存中某个固定位置（静态生命周期）的字符串切片的引用。
        // 所以写 let d: &str = "hhhhh"; 是完全正确的，类型匹配，编译器也知道 &str 的大小（8 字节，在 64 位系统下，是一个指针）。
        let d:&str = "hhhhh";
        println!("this is string {d}");
        
        // 其上等价于下面这种
        // 只是不同于以上的 d, 下面的 e 可以理解为一个 String 对象，它可以自带 push 和 push_str 方法，从而在当前创建的 String 的基础上添加更多内容
        // 但是需要注意的是 当前定义的 d 和 e 这两个字符串是不可变的，为了让其可变，需要在定义时加上 mut 关键字
        let e:String = String::from("hhhhh");
        println!("this is the same string {e}");
        
        // 另外下面这个拼接才有效，是因为只有 String对象才能进行拼接行为，to_string 方法是将 &str 转为 String（堆上分配，有所有权），此时才能在其堆上的字符串后面追加对应的 新的 string 内容
        let f:String = d.to_string() + "fff";
        println!("more string content {f}");

        //  另外也可以做字符串的 拼接的补充
        let mut m:String = String::from("hhhhh");
        println!("the value of m is : {m}"); // 打印：the value of m is : hhhhh
        // 添加单个 char 使用 单引号
        m.push('a');
        println!("the value of m is : {m}"); // 打印 the value of m is : hhhhha
        //  添加多个 字符串
        m.push_str(" bertarm");
        println!("the value of m is : {m}");  // 打印： the value of m is : hhhhha bertarm
}

```

> 其中对于 Rust 的 `string` 类型做一下简单总结

| 特性           | `String`               | `str`（通常使用 `&str`） |
| -------------- | --------------------- | ------------------------ |
| 是否拥有数据？   | ✅ 拥有              | ❌ 借用                  |
| 可否修改？      | ✅ 可变               | ❌ 不可变                |
| 存储位置        | 堆（heap）            | 静态数据或堆中数据的引用    |
| 编译时大小？    | ✅ 已知               | ❌ 未知（必须使用引用）    |
| 转换成本        | 有内存分配（可能更慢）  | 无拷贝，轻量              |




### 3. `hashMap<K, V>` — 哈希映射

相当于其他语言中的`「字典(python) / 对象(js) / Map (java/c#)」`，用来存储键值对。

```rust

use std::collections::HashMap; // 调用标准库

fn main() {
    //  创建一个 hash map
    let mut scores: HashMap<String, i32> = HashMap::new();
    //  插入键值对
    //  注意 insert 的插入，如果原键值对不存在，就插入，如果存在，就直接覆盖掉，而不会报错
    scores.insert(String::from("Alice"), 50);
    scores.insert(String::from("Bob"), 70);

    println!("scores map: {scores:?}"); // 打印： scores map: {"Alice": 50, "Bob": 70}

    // 访问键值
    let alice_score: Option<&i32> = scores.get("Alice"); // Option 查询得到就返回对应的值，查不到就会得到一个 None
    println!("alice_score : {alice_score:?}"); // 打印： alice_score : Some(50)
    // 1. 使用 let 语法单独解析
    if alice_score.is_some() {
        // 这里面还可以这么写
        // 下面这是 Rust 1.65+ 引入的「let-else 语法」
        //  但是在实际使用时个人不推荐，因为 下面的 return 行为 会直接从整个 当前的 main 函数退出，导致后面的逻辑不会被执行
        //  但是由于当前 的 if 里面加了 alice_score.is_some() 判断，这从而避免的了 如果查询结果是 None 时，直接从当前 main 函数 直接 return 退出
        let Some(score) = alice_score else { return; };

        /*
          其上上面等价于 下面这段老版本代码，只是看起来有点啰嗦
          let score = match alice_score {
                Some(s) => s,
                None => return,
            };
        */ 

        println!("Alice's score 1: {}", score); // 打印： Alice's score 1: 50
    }

    // 2.直接在 if 条件判断中使用 let - else 语法
    if let Some(score) = alice_score {   
        println!("Alice's score 2: {score}"); // 打印： Alice's score 1: 50
    }

    //  使用match
    let scr = match alice_score {
        Some(sc) => sc,
        None => &-1  // 假设如果没能查询到，直接返回 -1，这里只是借用 -1而已
    };
    println!("Alice's score 3 : {scr}"); // 打印： Alice's score 3 : 50 ， 如果以上 alice_score 没能正常获取到， 此时能正常打印到 Alice's score 3 : -1


    // 下面这行代码表示： 如果能找到，就返回指定的值，如果没找到就返回 -1， 其实和上面我的代码基本类似，只是比我代码简洁一些
    // copied() 方法，就是取出值的拷贝，也就是将 get 方法得到的 Option<&i32> 中的值取出来
    // 注意： 如果 scores.get("Bertram") 不是 Copy 类型，比如 String，copied() 就不能用了，需要 .cloned()
    let sre = scores.get("Bertram").copied().unwrap_or(-1);
    /*
     上面就等级于下面代码：
     let sre = match scores.get("Bertram") {
        Some(&v) => v,   // 取出值的拷贝
        None => &-1,      // 没找到就用默认值 -1
     };
    
    */ 
    println!("the Bertram score is {sre}"); // 打印： the Bertram score is -1
    

    //  还可以直接一键获取修改
    // 使用 get_mut 获取 "Alice" 的可变引用
    if let Some(alice_score) = scores.get_mut("Alice") {
        *alice_score += 10; // 解引用后直接修改
    }



    // 遍历, 注意下面只是借用 &scores，没有改变 ownership
    /* 
        以下便利打印：
        Bob: 70
        Alice: 60  // 因为上面手动 利用 get_mut 进行了修改
    */
    for (key, value) in &scores {
        println!("{}: {}", key, value);
    }


    // 删除键值对 , 删除键 "Bob"
    println!("before delete: {scores:?}");  // 打印： before delete: {"Bob": 70, "Alice": 60}
    if let Some(value) = scores.remove("Bob") {
        println!("deleted value:  {value}");  // deleted value:  70
    } else {
        println!("Bob score not existed !"); 
    }
    println!("after delete: {scores:?}"); // after delete: {"Alice": 60}

}

```



> 除了常见的，以下是对 集合类型 （Collection Types）一些小小的总结


| 类型             | 是否有序      | 是否允许重复   | 访问方式          | 适用场景        |
| --------------- | ------------- | -----------   | ---------------- | -------------  |
| `Vec<T>`        | ✅ 按插入顺序 | ✅ 允许重复   | 通过索引或迭代     | 顺序数据、列表  |
| `String`        | ✅ 按字符顺序 | ✅ 允许重复   | 通过切片、字符迭代 | 文本处理        |
| `HashMap<K,V>`  | ❌ 无序       | ✅（键唯一）  | 通过键访问        | 键值映射        |
| `BTreeMap<K,V>` | ✅ 有序键     | ✅（键唯一）  | 通过键访问        | 需要排序的映射   |
| `HashSet<T>`    | ❌ 无序       | ❌ 不允许重复 | 通过迭代或查找    | 唯一集合         |
| `BTreeSet<T>`   | ✅ 有序       | ❌ 不允许重复 | 通过迭代或查找    | 唯一 + 有序集合  |


> 同时对于 `collection` 数据的存储，也可以参考下面这段总结：

除了`数组(tuple)`是一个特例,它是 `Collection 集合`，但是它不是Rust中的标准`「集合类型 （Collection Types）」` ，它是 `复合类型（Compound Types）`
`它们的值本身（即集合这个“结构体”）存在栈(stack)上，而集合里面存放的「元素数据」通常存储在堆(heap)上`。

> Rust 中几乎所有标准 `「集合类型 （Collection Types）」` 的本体都在栈上，数据都在堆上。

| 类型                           | 元信息（struct）位置   | 元素存储位置 | 内部实现               | 是否堆分配     |
| ----------------------------- | --------------------  | ----------- | ---------------------- | --------------|
| `Vec<T>`                      | 栈上                 | 堆          | 连续数组                | ✅ 是         |
| `String`                      | 栈上                 | 堆          | 实际上是 `Vec<u8>` 包装 | ✅ 是         |
| `HashMap<K, V>`               | 栈上                 | 堆          | 哈希桶（数组 + 链表）    | ✅ 是         |
| `HashSet<T>`                  | 栈上                 | 堆          | 基于 `HashMap` 实现     | ✅ 是         |
| `VecDeque<T>`                 | 栈上                 | 堆          | 环形缓冲区              | ✅ 是         |
| `BTreeMap<K, V>` / `BTreeSet` | 栈上                 | 堆          | B-Tree 节点结构         | ✅ 是         |
| `[T; N]`（数组）               | 栈上                 | 栈          | 固定大小                | ❌ 否（在栈上）|


## D、特殊类型

由于不常用，暂时不做过多比较




# 二、重要知识补充：

## 数据存储在  `栈（stack）` 和 `堆（heap）` 上的区别

| 对比项       | 栈（Stack）                  | 堆（Heap）                             |
| --------- | ------------------------- | ----------------------------------- |
| **内存管理**  | 编译器自动管理（LIFO - 后进先出）      | 程序员控制，通常需要 `Box`, `Vec`, `String` 等 |
| **分配速度**  | 极快（基本是指针移动）               | 较慢，需要操作分配器                          |
| **释放方式**  | 自动（作用域结束时）                | 手动或借助智能指针（如 `Box`, `Rc`）            |
| **内存连续性** | 连续的内存区域                   | 可能是碎片化的，非连续                         |
| **访问速度**  | 更快：由于连续、局部性好、CPU cache 友好 | 相对慢：需要间接寻址                          |
| **大小限制**  | 通常有限（几 MB）                | 大量内存（受限于系统内存）                       |
| **用途适合**  | 小、临时、固定大小的数据              | 大、动态、可变大小的数据                        |

简单总结：

- `栈`：快、轻量、连续内存，适合小数据、短生命周期
    - 这是因为以下几点：
        - 栈上的数据是连续分布的，访问时 CPU cache 命中率高，读取写入速度极快，比如 `array`。
        - 栈内存的分配与回收几乎没有开销 ——> 只需移动栈顶指针
        - 需要注意，虽然 元组 `tuple` 可以存储不同类型的数据，这是因为编译器会根据每个字段的类型大小和对齐需求来 排列这些字段，使得整个结构依然可以连续存储在`栈`上,所以 tuple 默认还是会存储在栈`stack`上的， 即使加了 mut 变成可变，如： `let mut test_tuple1 = ("qqqq", 1, true);`,  因为此时长度依然是固定大小的，依然是  `16 + 4 + 1 + padding`, 另外这种操作 `test_tuple1.1 = 42;`,不会导致它从栈迁移到堆, 因为其大小本质并未改变

- `堆`：慢、灵活、适合动态数据，适合长期持有或大小不定的数据
    - 这是因为以下几点：
        - 栈的空间是有限的，并且在编译期必须知道变量的确切大小.
        - 栈上的变量在离开作用域时就销毁，而堆上生命周期可变、跨作用域.
        - 堆上是大小可增长的集合，比如，Rust 的 Vec<T> 就是堆分配的，因为它可以不断 push.
        - 栈通常只有几 MB（例如 1~8MB）,大数组或大对象放在栈上容易造成 stack overflow

Rust 编译器很智能，会尽量将数据放在栈上，只有你显式使用 Box, Vec, String 等时才会用堆

另外需要非常注意：

> `堆`和`栈`都在`内存（RAM）`中·，只是属于`内存的两个不同“管理区域”`,也就是最重要的两句话：
> - ✅ 栈（Stack）和堆（Heap）都属于 运行时内存（RAM）
> - ❌ 它们都不是硬盘，硬盘是持久存储，完全不同



# 三、以上数据类型的存储的默认位置对比

| 类型类别      | 示例/说明                       | 默认分配位置                     | 说明                                            |
| --------- | --------------------------- | -------------------------- | --------------------------------------------- |
| **标量类型**  | `i32`, `u64`, `f32`, `bool` | ✅ 栈                        | 固定大小，大小在编译期可知                                 |
| `char`    | 单个字符（Unicode）               | ✅ 栈                        | 4 字节 UTF-32 编码                                |
| **元组**    | `(i32, f64, bool)`          | ✅ 栈（若元素全是栈）                | 元组本身栈上存储，若包含堆元素（如 `String`）则部分指向堆             |
| **数组**    | `[u8; 16]`                  | ✅ 栈                        | 长度固定；大数组可能导致栈溢出，建议用 `Box`                     |
| **字符串切片** | `&str`                      | ✅ 栈（引用本身）<br>📦 堆或静态区（被引用） | `&str` 本身是栈上的胖指针，内容可能在静态区或堆中（如字符串字面量 vs 动态生成） |
| **单元类型**  | `()`                        | ✅ 栈                        | 仅占 0 字节，无需内存                                  |
| **发散类型**  | `!`                         | ❌ 不存在分配                    | 不返回，因此不需要栈/堆空间                                |

# 四、对以上数据类型存储的位置补充

| 类型       | 默认位置              | 说明           |
| -------- | ----------------- | ------------ |
| `String` | 📦 堆              | 栈上有指针，真实内容在堆 |
| `Vec<T>` | 📦 堆              | 动态大小的数组      |
| `Box<T>` | 📦 堆              | 显式把值放入堆      |
| `&[T]`   | ✅ 栈（引用）+ 内容📦堆/静态 | 引用在栈，内容不定    |


总之：堆越大，一般而言，越慢，但是有了栈上的指针，可以加快读和写，从而提高效率，换一句话说，即使堆再大，只要有正确的指针在栈上，并不影响其读写速率.



# 四、一些 额外的 补充

在 `Rust` 中，`isize` 和 `usize` 是 `指针大小的整数类型`，它们的`大小`与`平台架构`有关，通常用于与`内存索引`、`地址`相关的操作。下面详细解释：

- 基本概念

| 类型      | 描述                 |
| ------- | ------------------ |
| `isize` | 有符号整数，其位数与平台指针大小相同 |
| `usize` | 无符号整数，其位数与平台指针大小相同 |

- 其中不同的平台类型如下：
  - 指针大小：
      - 在 32 位系统上是 32 位（4 字节），
      - 在 64 位系统上是 64 位（8 字节）。

所以：

`32 位平台`：isize 和 usize = 4 字节
`64 位平台`：isize 和 usize = 8 字节

- 其中多对应的证书范围如下：

| 类型     | 32 位系统范围                                   | 64 位系统范围                                     |
| --------| ----------------------------------------------- | ---------------------------------------------------------------------- |
| `isize` | -2,147,483,648 (-2^31) ~ 2,147,483,647 (2^31-1) | -9,223,372,036,854,775,808 (-2^63) ~ 9,223,372,036,854,775,807(2^63 -1)|
| `usize` | 0 ~ 4,294,967,295 (2^32 -1)                     | 0 ~ 18,446,744,073,709,551,615   (2^64 -1)                             |
