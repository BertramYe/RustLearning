# 简单说明

对于数据结构，基本所有语言都一致，其中，对于 数据结构，以下只是记录一些我平时学习过程中的一些 `rust` 的一些特例而已，
其中如果学过和使用过 `TypeScript` 和 `C#` 基本都类似，基本都大差不差的


# 一、原始类型 (Primitive Types)

详细参考官方文档：https://doc.rust-lang.org/book/ch03-02-data-types.html

对于 `Rust` 的原始数据类型`（Primitive Types）`可以做一下下面的简单归类，

- ✔️ 标量类型（Scalar Types）
    - 整型：i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize
    - 浮点型：f32, f64,....
    - 布尔型：bool
    - 字符型：char

- ✔️ 复合类型（Compound Types）
    - 元组：(T1, T2, ...)
    - 数组：[T; N]

- ✔️ 特殊类型
    - 字符串切片：str（常见为 &str）
    - 单元类型：()（函数无返回值）
    - 发散类型：!（如 panic!、loop {}）

> 注意： rust中的字典类型，被称为 `hashMap`, 它是 `Rust` 标准库中提供的一种 `关联容器`（associative container）, 它因该被理解为一个对象，而不再归类为`Rust`的原始的数据类型 (primitive types)

## A、标量类型（Scalar Types）

详细如下面这段函数， 在 `Rust` 中常常将 `int`,`float`,`bool`,`char` 这四个最基础的数据类型归为标量类型

```rs

fn main() {
    // i 表示正负整数都行
    let a:i32 = 18;
    // 下面这两种打印都可以，rust 中利用 {} 作为占位符，同时 {a} 只有在 rust 1.58 之后生效,而当前为 1.88.0， 所以后面为了方便，直接全部使用最新语法 {a} 进行打印和占位
    println!("this is the int type {}",a);
    println!("this is the int type {a}");

    // u 表示所有自然数，也就是非零的整数  
    let b:u32 = 18;
    println!("this is the int type {b}");
    
    // 对于 char 类型，永远只能使用单引号表示，不能使用双引号,因为双引号表示 一段 UTF-8 编码的字符串切片
    // Rust 的单个 char 是 4 字节，支持 Emoji 和非 ASCII 字符,故而对于中文（通常一个中文占用 3 个字节（bytes））也有很好的支持
    let c:char = 'h';
    println!("this is char {c}");

    // 浮点数
    let d:f32 = 0.31;
    println!("this is float {d}");
    // 下面的计算结果 得到的结果为 -0.019999996， 这是因为 计算机的 二进制转换导致的计算精度问题
    // 这个问题在所有语言中都存在，包括 Python, Java,nodejs, c# 等等
    let e:f32 = 0.1 - 0.12;
    println!("this is  count float {e}");
    
    // 布尔值
    let g:bool = false;
    println!("this is the bool value {g}");
}

```



## B、复合类型（Compound Types）


### 1. array 数组

其中对于数组，感觉最重要的也就以下几点

- 同一数组只能保存相同的数组类型
- 普通的固定大小数组（例如 `let array2:[i32;5] = [1,2,3,4,5];`），它们通常存储在`栈（stack）`上。栈是一个 快速 的内存区域，它存储函数的局部变量以及函数调用的返回地址等。
- 动态数组（如 `Vec<T>`）的元素存储在`堆（heap）`上，但是`栈`上还会存储指向`堆`的`指针`。
- Rust 中数组的内存布局是连续的，无论是栈上还是堆上的数组，元素的内存都是紧凑的，不会有额外的间隔。这种内存布局为 `Rust` 提供了高效的性能和内存管理，避免了 `GC（垃圾回收）`和不必要的内存分配。

```rs
fn main() {
    //  可以不定义类型，从而进行隐式定义和转换，注意下面不会报错，同时对于其他类型的数据也是一样的
    let array1= [1,2,3,4,5];
    println!("this is array: {array1:?}");
    // 等价于下面的这种定义方式
    // 其中下面 i32 代表数组类型， 同时 5 代表数组长度或者说 size
    let array2:[i32;5] = [1,2,3,4,5];
    println!("this is array: {array2:?}");

    // 除了上面这个定义，还可以像下面这种进行变相类型定义
    // 简单来说这里 numbers_slice 是一个切片（slice）对象， & 表示“借用(borrow)”，而 i32 是数组元素的类型,同时切片可以不指定切片的长度。
    // Rust 标准库为切片类型（如 &[i32]）实现了 Debug trait，因此可以直接打印切片的内容。{:?} 会打印切片中的所有元素。
    let numbers_slice:&[i32] = &[1,2,3,4,5];
    // 注意，由于切片 slice 是动态的，所以不能像下面这样，指定切片长度为 5 ，这一点和数组 array 是不同的
    // let numbers_slice:&[i32,5] = &[1,2,3,4,5];  // 切片只是 array 的一部分，是动态的，不能指定长度, 所以这行代码会报错
    println!("the numbers of the slice {numbers_slice:?}");

    // 更多有意思的可以参考下面
    //  创建一个存储在 堆(heap) 上的动态字符串 string_temp
    let string_temp:String = String::from("Hello world!");
    // String 类型的 &str 切片是对字符串的一种轻量级引用，&str 是一个不可变的借用，它引用了 String 的一部分或者整个内容，但不会获取所有权。str_ref 是指向 string_temp 的引用。
    // 简单来说 str_ref 是栈上的一个引用（指针），指向堆上的数据 string_temp，同时不指定切片大小 （即借用的堆上的数据的大小， 可以像下面 [0..5] 的索引长度来表示），默认就获取全部
    let str_ref: &str = &string_temp;
    println!("str ref : {str_ref:?}");
    // str_ref 中提取从索引 0 到索引 5 之间的部分（不包括索引 5），即 "Hello"
    // 需要注意的是，Rust 中的切片操作基于字节索引，对于 UTF-8 编码的字符，切片需要遵循有效的字符边界。在这里，"Hello" 中的字符都是有效的字节，所以没有问题。
    let part_str_ref:&str = &str_ref[0..5];
    println!("part str ref : {part_str_ref:?}");
    // 总之, 通过使用切片和引用，Rust 可以避免复制数据，从而提高效率。

    // 通过使用切片和引用，Rust 可以避免复制数据，从而提高效率。
    let chinise_string:String = String::from("这是一段中文！");
    let temp_ch_1:&str = &chinise_string[0..6];  // 这行的打印是 “这是” 
    println!("test for the chinines 1: {temp_ch_1:?}");
    //  下面这个会报错， 因为 一个中文是三个字节。而下面截取的是 0-4，所以会报错
    let temp_ch_2 :&str = &chinise_string[0..5];  // 报错，一个中文占据 3 个字节
    println!("test for the chinines 1: {temp_ch_2:?}");

    // 故此对于字符串，为了解决中英文混合的问题，可以借助 chars 来帮助实现按照
    // chars()：将字符串转换为一个字符迭代器，每次迭代返回一个 char，即一个 Unicode 字符，此时每个 char 大小为 4 字节，足够容纳单个中文的 3 字节长度， 也能够容纳单个英文 1 字节长度，这样就完美解决了中英文混用的切片不准确的问题， 毕竟 3 < 4 而且 1 < 4, 如果有其他语言中的单个 字符串 长于 4 字节，此时需要另外的方式来解决这个问题了
    let chinese_string:&str = "Hello 你好 Rust 世界！";
    // 获取前 6 个字符（不按字节）
    let substring_1: String = chinese_string.chars().take(6).collect(); // 默认从 chars 的索引 0 开始，往后面取 6 位
    println!("substring_1: {substring_1:?}"); // 打印结果为： substring_1: "Hello "
    // 获取字符索引范围从 7 到 14 (即 6 + 9 - 1) 的字符串， 也就是是，首先跳过前 0~5 位字符串 （字符索引从 第 6 位开始），开始往后面数 9 位字符串
    let substring_2: String = chinese_string.chars().skip(6).take(9).collect();
    println!("substring_2: {substring_2:?}"); // 打印结果为： substring_2: "你好 Rust 世"

    // 同时相对而言，根据当前的 Unicode 标准，没有字符的编码超出 4 字节，所以以上方式基本可以通用任何字符串的混合问题。
    // 但是如果你发现某些字符超过 4 字节，可能是由于：
    // - 字符集本身的编码方式（如 UTF-16、UTF-32）。
    // - 其他非标准编码方式或扩展字符集。



    //  在rust中 也可以利用索引获取 array 内的值
    let fist_value = array2[0];
    println!("this is array: {fist_value}");

    // 同时对于 以上打印时需要加上 :? 是因为
    // 默认情况下，Rust 会使用 Display 格式来打印类型，这通常是针对 toString 或 println! 默认打印的方式。
    // 当你打印数组（或其他类型）时，使用 :? 会让 Rust 使用 Debug 格式来输出内容，而不是 Display 格式。
    // Debug 格式则提供了一种用于调试时更详细、更易理解的输出格式。
    // 如果不加 :?，Rust 会尝试用默认的 Display 格式打印数组，但数组类型没有实现 Display，因此会报错。
    // 总结来说，:? 是为了让你在打印调试信息时，看到更清晰、更详细的输出。


    //  另外 array 数组的定义时，在 rust 中一个数组内存储的只能是相同类型的数据，这对于其他的编程语言（如Python）是不一样的
    let aa = [1,'a'];  // 会报错，这是因为 当前数组存储了两个类型数据 int 和 string, 这在 rust中是不允许的


    //  以下简单展示 不同 array 存储的位置
    let vec1 = [1, 2, 3, 4, 5]; // 存储在栈上
    // Vec 是 动态数组 类型，是标准库提供的一个集合类型，用于存储可变长度的元素,可以在运行时增长或缩小，适用于元素数量不确定的情况。
    // 创建一个空的 Vec 可变数组
    let mut dynamic_array = Vec::new(); // 创建一个空的 Vec
    dynamic_array.push(1); // 向 Vec 添加元素
    dynamic_array.push(2);
    dynamic_array.push('jjjj'); // 即便是可变数组，但是仍然需要保证数组内存储的元素的类型一致，故而这行代码会报错。
    
    println!("dynamic array : {dynamic_array:?}");

    // vec! 宏是 Rust 标准库中的宏，允许你在一行代码中创建并初始化一个 Vec。
    let vec2:Vec<i32> = vec![1, 2, 3, 4, 5]; // 存储在堆上
    println!("stack array: {:?}", vec1);
    // 下面这两种打印等价
    println!("stack array: {vec2:?}");
    println!("heap array: {:?}", vec2);
}


```

### 2. tuple 元组

相比较以上的`array`中，同一个`array`只能存储,单一的一种数据类型，为了实现多种不同类型数据的存储，可以使用 `tuple` 元组进行数据存储,同时 `tuple` 默认都是存储在 `stack` 栈上的，即使加了 `mut`, 变成可变 元组，另外，元组 `tuple` 虽然存储不同类型的数据，可能会被误认为其数据存储是在 `堆 (heap)`上，但是由于 Rust编译器会根据每个字段的类型大小和对齐需求来排列这些字段，使得整个结构依然可以连续存储在`栈`上,所以 `tuple` 默认还是会存储在栈`stack`上的 ：

```rs
fn main() {
   // 直接隐式定义一个 tuple 类型
   // 虽然下面存储了不同的数据类型，但是 Rust 编译器会根据每个字段的类型大小和对齐需求来排列这些字段，使得整个结构依然可以连续存储在`栈`上,
   // 所以 `tuple` 默认还是会存储在 栈`stack`上的
   let test_tuple1 = ("qqqq",1,true);
   //  存储在 栈上， 即使加了 mut 变成可变，
   //  这是因为此时 下面的 tuple 的长度依然是固定的， 大小依然是  16 + 4 + 1 + padding
   let mut test_tuple1 = ("qqqq", 1, true);
   //  同时 下面的修改 依然不会导致它从栈迁移到堆, 因为只是改变其存储的内容，并未改变存储的类型，同时大小也并未改变
   test_tuple1.1 = 42;
   test_tuple1.2 = false;
   // 注意下面修改是违法的， 这是因为 tuple 的 第 1 位 在定义时是  int 类型， 你不能将其转化为 char 类型，会报错
   test_tuple1.1 = 'a';
 
   //  显示定义和显示 tuple 类型
   let test_tuple2 :(&str,i32,bool,[i32;5]) = ("aaaa",1234,false,[1,2,3,4,5]);
   //  为了输出显示，一样需要使用 debug 进行打印结果
   println!("test tuple : {test_tuple1:?}");
   println!("test tuple 2: {test_tuple2:?}");
}

```






## C、特殊类型

对于特殊类型，下面主要列出和解释一下常用的 `string` 类型

```rs

fn main() {
        // 对于使用 双引号定义的 字符串，其类型只能指定为 “&str”
        // 这是因为：
        // str 表示的是一段 UTF-8 编码的字符串切片，但它的长度在编译时是未知的。
        // Rust 需要在编译时知道变量的大小（以便正确分配内存和栈空间），而 str 是 不具有已知大小的类型。
        // 所以下面你不能写 let d: str = "hhhhh";，因为编译器无法为 str 类型分配固定大小的内存。
        // "hhhhh" 是一个字符串字面量，它的类型是 &'static str，这是一个指向内存中某个固定位置（静态生命周期）的字符串切片的引用。
        // 所以写 let d: &str = "hhhhh"; 是完全正确的，类型匹配，编译器也知道 &str 的大小（8 字节，在 64 位系统下，是一个指针）。
        let d:&str = "hhhhh";
        println!("this is string {d}");
        
        // 其上等价于下面这种
        // 只是不同于以上的 d, 下面的 e 可以理解为一个 String 对象，它可以自带 push 和 push_str 方法，从而在当前创建的 String 的基础上添加更多内容
        // 但是需要注意的是 当前定义的 d 和 e 这两个字符串是不可变的，为了让其可变，需要在定义时加上 mut 关键字
        let e:String = String::from("hhhhh");
        println!("this is the same string {e}");
        
        // 另外下面这个拼接才有效，是因为只有 String对象才能进行拼接行为，to_string 方法是将 &str 转为 String（堆上分配，有所有权），此时才能在其堆上的字符串后面追加对应的 新的 string 内容
        let f:String = d.to_string() + "fff";
        println!("more string content {f}");
}

```

> 其中对于 Rust 的 `string` 类型做一下简单总结

| 特性      | `String`    | `str`（通常使用 `&str`） |
| ------- | ----------- | ------------------ |
| 是否拥有数据？ | ✅ 拥有        | ❌ 借用               |
| 可否修改？   | ✅ 可变        | ❌ 不可变              |
| 存储位置    | 堆（heap）     | 静态数据或堆中数据的引用       |
| 编译时大小？  | ✅ 已知        | ❌ 未知（必须使用引用）       |
| 转换成本    | 有内存分配（可能更慢） | 无拷贝，轻量             |



# 二、重要知识补充：

## 数据存储在  `栈（stack）` 和 `堆（heap）` 上的区别

| 对比项       | 栈（Stack）                  | 堆（Heap）                             |
| --------- | ------------------------- | ----------------------------------- |
| **内存管理**  | 编译器自动管理（LIFO - 后进先出）      | 程序员控制，通常需要 `Box`, `Vec`, `String` 等 |
| **分配速度**  | 极快（基本是指针移动）               | 较慢，需要操作分配器                          |
| **释放方式**  | 自动（作用域结束时）                | 手动或借助智能指针（如 `Box`, `Rc`）            |
| **内存连续性** | 连续的内存区域                   | 可能是碎片化的，非连续                         |
| **访问速度**  | 更快：由于连续、局部性好、CPU cache 友好 | 相对慢：需要间接寻址                          |
| **大小限制**  | 通常有限（几 MB）                | 大量内存（受限于系统内存）                       |
| **用途适合**  | 小、临时、固定大小的数据              | 大、动态、可变大小的数据                        |

简单总结：

- `栈`：快、轻量、连续内存，适合小数据、短生命周期
    - 这是因为以下几点：
        - 栈上的数据是连续分布的，访问时 CPU cache 命中率高，读取写入速度极快，比如 `array`。
        - 栈内存的分配与回收几乎没有开销 ——> 只需移动栈顶指针
        - 需要注意，虽然 元组 `tuple` 可以存储不同类型的数据，这是因为编译器会根据每个字段的类型大小和对齐需求来 排列这些字段，使得整个结构依然可以连续存储在`栈`上,所以 tuple 默认还是会存储在栈`stack`上的， 即使加了 mut 变成可变，如： `let mut test_tuple1 = ("qqqq", 1, true);`,  因为此时长度依然是固定大小的，依然是  `16 + 4 + 1 + padding`, 另外这种操作 `test_tuple1.1 = 42;`,不会导致它从栈迁移到堆, 因为其大小本质并未改变

- `堆`：慢、灵活、适合动态数据，适合长期持有或大小不定的数据
    - 这是因为以下几点：
        - 栈的空间是有限的，并且在编译期必须知道变量的确切大小.
        - 栈上的变量在离开作用域时就销毁，而堆上生命周期可变、跨作用域.
        - 堆上是大小可增长的集合，比如，Rust 的 Vec<T> 就是堆分配的，因为它可以不断 push.
        - 栈通常只有几 MB（例如 1~8MB）,大数组或大对象放在栈上容易造成 stack overflow

Rust 编译器很智能，会尽量将数据放在栈上，只有你显式使用 Box, Vec, String 等时才会用堆

另外需要非常注意：

> `堆`和`栈`都在`内存（RAM）`中·，只是属于`内存的两个不同“管理区域”`,也就是最重要的两句话：
> - ✅ 栈（Stack）和堆（Heap）都属于 运行时内存（RAM）
> - ❌ 它们都不是硬盘，硬盘是持久存储，完全不同



# 三、以上数据类型的存储的默认位置对比

| 类型类别      | 示例/说明                       | 默认分配位置                     | 说明                                            |
| --------- | --------------------------- | -------------------------- | --------------------------------------------- |
| **标量类型**  | `i32`, `u64`, `f32`, `bool` | ✅ 栈                        | 固定大小，大小在编译期可知                                 |
| `char`    | 单个字符（Unicode）               | ✅ 栈                        | 4 字节 UTF-32 编码                                |
| **元组**    | `(i32, f64, bool)`          | ✅ 栈（若元素全是栈）                | 元组本身栈上存储，若包含堆元素（如 `String`）则部分指向堆             |
| **数组**    | `[u8; 16]`                  | ✅ 栈                        | 长度固定；大数组可能导致栈溢出，建议用 `Box`                     |
| **字符串切片** | `&str`                      | ✅ 栈（引用本身）<br>📦 堆或静态区（被引用） | `&str` 本身是栈上的胖指针，内容可能在静态区或堆中（如字符串字面量 vs 动态生成） |
| **单元类型**  | `()`                        | ✅ 栈                        | 仅占 0 字节，无需内存                                  |
| **发散类型**  | `!`                         | ❌ 不存在分配                    | 不返回，因此不需要栈/堆空间                                |

# 四、对以上数据类型存储的位置补充

| 类型       | 默认位置              | 说明           |
| -------- | ----------------- | ------------ |
| `String` | 📦 堆              | 栈上有指针，真实内容在堆 |
| `Vec<T>` | 📦 堆              | 动态大小的数组      |
| `Box<T>` | 📦 堆              | 显式把值放入堆      |
| `&[T]`   | ✅ 栈（引用）+ 内容📦堆/静态 | 引用在栈，内容不定    |


总之：堆越大，一般而言，越慢，但是有了栈上的指针，可以加快读和写，从而提高效率，换一句话说，即使堆再大，只要有正确的指针在栈上，并不影响其读写速率.