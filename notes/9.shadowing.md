
# 简单说明

`Rust` 中的 `Shadowing（变量遮蔽）`是指在同一作用域内重新声明同名的变量，
从而`"遮蔽"`或`"覆盖"`之前的变量。这并不是`修改`原变量的值，而是`创建`一个新的变量，`名称相同`，`但可以拥有不同的类型或值`。

其主要有以下特点：

 - `不改变原变量的值`：每次使用 `shadowing` 时，都会创建一个新的变量，并用新值覆盖旧值。原变量的内存位置和原值不变。
 - `允许改变类型`：不同于不可变变量，它允许在同一作用域内使用不同的类型，例如将一个 `i32` 变量 `shadow` 成一个 `f64` 类型的变量。
 - `作用域局限性`：每个 `shadowing` 只在其所在的`作用域`内有效，`过了作用域后原始变量恢复有效`。


# 一个经典的例子如下

需要注意的是： 对于下面的例子中，
在 `Rust`中，变量的 `销毁` 是由 `作用域` 管理的。`只有当变量的作用域结束时，变量才会被销毁，即释放内存`。
因此，在 `内层作用域（代码块内）` 进行变量 `遮蔽` 时，`外部的原始变量并不会立即被销毁`。它仍然有效，并且会在内层作用域结束后恢复。

`遮蔽` 变量本质上是 `创建一个新的变量`，并使用`新的值或类型替代原始变量`。`原变量并不会在遮蔽时销毁，而是等到其作用域结束后才会被销毁`。

如果新旧变量的 `类型`和`大小`一致，并且是在栈上的数据（例如 `i32`、`bool` 等基本类型），`Rust` 会复用原有的内存位置，并且 不会增加内存的使用。
然而，对于堆上分配的类型（例如 `String`、`Vec` 等），即使新旧值大小相同，`Rust` 通常会为`新变量分配新的内存`，因为它们通常是不同类型或引用不同内存块。


> 总结一下： 同一层级作用域内的遮蔽会只会有一块内存的消耗，而不同级别作用域的遮蔽，会有多块内存的消耗。

因为当变量在同一层级的作用域内被遮蔽时，新的变量并不会分配新的内存，而是 覆盖 原始变量的内存位置。
也就是说：
 - 栈内存：原始变量在栈上分配一块内存空间，当进行遮蔽时，新的变量会复用这块栈内存，并替换掉原来的值。
 - 内存消耗：因为只是复用原来的内存，所以 只有一块内存 被消耗。

```rust
/*
 这里，a 的值从 5 变为 6，但栈上只有一块内存。在 let a = a + 1; 这行代码中，
 原本的 a 被新的 a 变量所覆盖，内存没有增加，只有一个 a 在栈上占用内存，值变成了 6。
*/ 
fn main() {
    let a = 5;  // 创建一个栈上的整数 x，值为 5
    let a = a + 1;  // 通过 shadowing 创建新的 a，值为 6
    println!("a: {}", a);  // 输出：6
}


```


当`遮蔽`发生在 `不同的作用域` 时，`新的变量和原始变量会分别占用各自的内存区域`：
  - `内存消耗`：因为内层作用域的变量是全新的，它会在栈上分配新的内存，并且可能还涉及堆内存（如 String）。
  - `栈和堆内存`：内层作用域的变量遮蔽了外层的变量，但内层作用域内的变量会 独立分配内存。因此，在不同作用域的遮蔽会导致 内存的增加。

```rust

/*
在内层作用域内，let a = a.to_string() + "aaa"; 会创建一个新的 String 类型的变量 a，它会分配新的堆内存来存储 "hhhhhaaa"。
在外层作用域，原始的 a 仍然有效，它是一个 &str 类型，存储 "hhhhh"。这两个变量并不会共享内存，而是分别占用栈和堆上的内存区域。

为什么会如此？

这是因为，在 内层作用域 中，a.to_string() 生成了一个新的 String 类型，并且在堆上分配了内存。内层作用域的 a 会遮蔽外层作用域的 a，但是内层的 a 会创建新的内存块来存储数据。
当内层作用域结束时，内层的 a（String 类型）会被销毁，而外层作用域的 a（&str 类型）会恢复。

*/
fn main() {
    let a: &str = "hhhhh";

    //  注意下面是 rust 的一个代码块（code block）, 它会像普通代码一样被执行，只是不同点在于作用域的问题
    {
        //  这一步会 先拿到 原来的 a 的值进行拼接，接着会将上面的 a 进行遮蔽，在当前 代码块的作用域中使用新的 a
        let a = a.to_string() + "aaa"; 
        println!("the inner a value is {a}"); // 会打印 ： the inner a value is hhhhhaaa
    }

    // 注意下面的 a.len() 之所以能够返回 "hhhhh" 的长度 5，是因为 原始的 a 仍然在外部作用域中有效，并没有被销毁。
    // 这一步开始，上面的代码块被运行完了，
    // 原来被遮蔽的a （即 hhhhh ）会先被释放出来，
    // 然后拿到原来 的长度 a.len()， 在将原来的a被新的a进行遮蔽，从这里开始，用新的 a 将会作用于下面的整个过程
    // 注意，下面的数据类型也从原来的 &str 变成了 usize
    let a: usize = a.len();
    let a: usize = a * 2;
    println!("the outer value of  a is {a}"); // 会打印： the outer value of  a is 10
}


```


从以上的例子可以看出 `shadowing` 主要有以下几个好处：

 - `避免不可变借用的麻烦`：可以通过 `shadowing` 来修改变量的值，而不需要明确地使用 `mut（可变）`修饰符,同时使用 `mut` 时，还需要保证新的值的类型和原来的定义时，必须一致。
 - `简化代码`：你可以通过 `shadowing` 改变变量的类型，避免额外的类型转换步骤。
 - `增加可读性`：有时候 `shadowing` 比直接修改值更简洁，尤其是在同一作用域内变量值的变化比较频繁时。



# 简单总结：

对于 Rust 中的 shadow 而言，有好处也有弊端：

- `Shadowing` 是通过创建一个`新的变量`来实现的，`不是通过修改原有的变量`。这意味着它会`完全替换旧的变量`，而`不会在内存中直接修改`。
- 因为变量值在`同一作用域内被遮蔽`，可能会导致一些理解上的困惑，特别是`当同名变量的类型不同时`。
- 在 `Rust` 中，如果新旧的值大小和类型一样 (在同一作用域上)， `Shadowing` 不会导致内存的增加，因为本质的遮蔽，只会保留 `一个` 同名变量存在。每次通过 `shadowing` 创建的新变量，只是在原变量的作用域中`重新创建和绑定了一个新的值`，`而不会额外分配内存或增加内存使用`，因为此时原变量和值已经没用了，会被销毁。具体来说，`Shadowing` 会创建一个新的变量，并将`它与新的值（或者新的类型）绑定`。这个过程依赖于原变量的类型和新的值的类型，是否会增加内存取决于值的类型和它在堆上的分配方式。同时默认情况下，`shadowing` 会`销毁原数据并释放内存`，`除非你显式地使用 clone 或其他方法来保留原数据`。
   
   - 对于`栈`上的值 （如普通的， `i16` , `i32` 等简单数据类型 ），`Shadowing` 会`覆盖变量名称的绑定`，但地址不会变化，因为栈上的内存是自动管理和复用的。
   - 对于`堆`上的值 （如 `String`、`Vec` 等数据类型），`Shadowing` 会创建一个`新的变量`，`并将新的值绑定到这个变量上`，可能会导致新的内存分配。原来的堆内存会在原变量离开作用域时被销毁（drop）。

> 所以，对于相同的遮蔽行为而言，同一作用域下，不会过多消耗内存，不同作用域下的遮蔽，会过多地消耗内存。





另外 补充一点关于  `RAII 原则`

`RAII（Resource Acquisition Is Initialization）原则` 是 资源获取即初始化 的缩写，是一种管理资源的编程惯例，特别是在 内存管理 和 资源释放 方面。

1. RAII 原则的核心思想：

`RAII 的基本思想是`：资源（如内存、文件句柄、网络连接等）的生命周期被绑定到对象的生命周期。
`当对象被创建时，它会获取资源；当对象离开作用域时，它会自动释放资源。`

`RAII` 在 `Rust` 中非常重要，`因为它使得资源管理变得更加简单和安全，避免了手动管理内存和资源的复杂性（例如，避免了内存泄漏和悬挂指针等问题）`。

2. 如何工作：

`资源获取（Acquisition）`：对象的构造函数（或者类似的函数）负责申请并初始化资源。
`资源释放（Release）`：当对象超出其作用域或被销毁时，其析构函数（Drop trait）会被自动调用，释放与该对象相关联的资源。

在 Rust 中，`RAII` 的实现依赖于 `所有权` 和`生命周期`。Rust 会确保当对象离开作用域时自动调用它们的 Drop 方法，从而释放资源。

3. `RAII` 在 `Rust` 中的实现：

`Rust` 通过其 `所有权系统 ownership` 来实现 `RAII`。具体来说：

`所有权 ownership`：每个值在 Rust 中只能有一个所有者，当所有者离开作用域时，值会自动被销毁。
`Drop trait`：当一个对象的生命周期结束时，Rust 会自动调用该对象的 Drop trait 的 drop 方法，释放它占用的资源.
`变量/代码块的的生命周期`：在 Rust 中，每个变量(或者代码块)都有一个明确的生命周期，它由变量(或者代码块)所在的作用域决定。这个作用域从花括号 `{` 开始，到花括号 `}` 结束。

```rust

struct File {
    name: String,
}

impl File {
    fn new(name: &str) -> File {
        println!("Opening file: {}", name);
        File {
            name: name.to_string(),
        }
    }
}

impl Drop for File {
    fn drop(&mut self) {
        println!("Closing file: {}", self.name);
    }
}

fn main() {
    {
        let _file = File::new("example.txt");
        // 文件在这里被打开并绑定到 _file 变量上
    } // _file 离开作用域，自动调用 drop() 方法，释放资源
    // 这里文件已经被关闭了
}


```